Soldier of Fortune - disassembly

Interrupts: IM2, mostly switched off, sometimes are switched on

<======================================>
1. Loader. After loading calls $A000
2. $A000. Pause. Wait for any key to be presed, then overwrites itself with 00 and jumps to $9D72
3. $9D72. Disables interrupts, then prepares interrupt table for IM2, by filling $100 bytes, 
starting with $FE00, by value $FD. This means that all interrupts will be handled by code located at $FDFD.
By this address a command JP $A223 is put. Then IM2 mode is switched, but interrupts are still disabled.
Register I is loaded with value $3F. If ROM address $1540 contains anything but $53, then $100 bytes 
are copied from $9DAD to $A272. Finally jumps to $A132 - main game loop

<======================================>

Video-mem:
==========
$4000 - $57FF - pixel data
$5800 - $5AFF - color data


Graphics data:
==============
(+16357)

right after video memory

$5B00 23296 6939  (4) - Graftgold logo big
            7067  (3) - Graftgold logo small
$5BB0 23472 7115  (1) - Font
            7443  (5) - Labyrinth blocks (till 11888)

$6E5E - packed levels

<======================================>

$77D2 (3*1) - dagger, 4 sprites right, 4 sprites left
$78DA (3*1) - arrow
      (3*1) - gem, 8 sprites
      (3*1) - super weapon
$7B92 (3*1) - bird A, 4 sprites right, 4 sprites left
      (3*1) - bird B

            15661 (4) - cloud
            15917 (4) - raft
            16173 (4) - platform
            16425 (4) - shooting block
      33042 16685 (4) - elemental
      33298 16941 (4) - skeleton
      33558 (4*3) - enemy: monk, 4 sprites right, 4 sprites left
            17965 (4) - enemy: monster
            18733 (4) - enemy: dragon bird
            19501 (4) - enemy: knight
$8F12 36626 20269 (4) - rock ball
$9612 38418 (4*3) - hero, 6 sprites right (4 steps + 1 jump + 1 crouch) + 6 sprites left
      39922 (4*3) - blow, 4 sprites

-----------------------------
$9D72 - $A132: Temp area.
Used for:
  * to create level's sprite set
  * to store unpacked map of current level. Each block takes 1 byte, each level row is $1E blocks wide

-----------------------------

$A132: Main loop - $A1F9 (+2 bytes)


$A132 CALL $E576  ;poop for menu,demo and high score table, exists when start key is pressed
$A139 CALL $A47B  ;prepare game screen (and print "get ready")
$A13C XOR A
$A13D LD ($C4B1), A
$A140 CALL $A58D  ;init graphics for new level

;$A143 - $A1F9 (+2 байта) - main loop of game itself
$A143 CALL $A6C8  ;init data for new level
$A146 LD SP,$0000
      CALL $A25F  ;play sound or wait
      CALL $C1B5  ;print the message
      CALL $C573  ;Keyboard query
      CALL $BAB2  ;Colliding dynamic objects list maintenance
      CALL $A8D4  ;?? Decrement timer, print hurry up message ??
      CALL $B5AD  ;?? collision detection?
      CALL $B4BB  ;?? check location triggers, activate monsters ??
      CALL $B527  ;check if player hits the monster
      CALL $B118  ;?? check fire button, create a weapon missile if needed ??
$A164 CALL $AF90  ;??
      LD C,$1B
      LD A,($C4BA)
      LD B,A
      LD D, $0D
      LD A,($C3A9)
      AND A
      JR NZ,$A177
      LD D,$16
$A177 LD A,($C4B0)
      CP $10
      JR Z,$A182
      CP $06
      JR NZ,$A186
$A182 LD A,D
      ADD A,$14
      LD D,A
$A186 LD A,B
      SUB D
      NEG
$A18A LD B,C
$A18B DJNZ $A18B
      DEC A
$A18E JR NZ,$A18A
$A190 CALL $D431      ;draw dynamic game screen
$A193 LD HL,$0000
      LD ($C4E6), HL
      CALL $A910      ;??? death handling ??
      CALL $C5E7      ;handle moving left and right, jump, fall down and sit down, with collision detection
$A19F CALL $A44C      ;screen scroll if we are riding a platform, or falling down
      LD HL,$C4AE
      LD A,(HL)
      AND A
      JP Z,$A1AE
      DEC A
      LD (HL), A
      JR $A1D8
$A1AE LD A, ($C4B0)
      LD B, A
      LD A, ($C4B6)
      LD C, A
      LD A, ($C4DA)
      LD D, A
      LD A, ($C4BF)
      OR B
      OR C
      OR D
      JR NZ, $A1D8
      LD A, $08
      LD ($C4AE), A
      LD HL, ($C3AA)
      LD ($C4A6), HL
      LD HL, $C4E8
      LD DE, $C4A8
      LD BC, $0006
      LDIR
$A1D8 CALL $BED1      ;update coordinates of dynamic objects
      CALL $C819      ;coord calculation
      CALL $B7A0      ;Monster and missile movement, collision to walls, falling down
      CALL $BDF7      ;Check if moving platform visible, and create a visible colliding object for it
      CALL $BAF6      ;?? check if statically placed collectable object becomes visible, and create a visible object entry for it
      CALL $B212      ;?? Generate random monster ??
      CALL $C30E      ;?? draw score on a screen ??
      CALL $CEDC      ;??
      CALL $A1FC      ;check pause?
$A1F3 JP C, $A146
$A1F6 CALL $A887
$A1F9 JP $A132

-----------------------------
$A1FC - проверка паузы? - $A222

$A1FC LD A,$22       ;код клавиши P ?
      CALL $C5AF     ;проверяем нажатие
      RET C          ;если не нажата, то выход (если не пауза?)
      .......
$A222 RET
 

<======================================>
$A223: Обработчик прерывания - $A22E

$A223 PUSH AF         ;сохраняем регистры, которые будут меняться
$A224 LD A,$3F
$A226 LD I,A          ;изменяет указатель таблицы прерываний (для запутывания?)
$A228 LD A,01
$A22A LD ($C4B9),A    ;???? (какой-то флаг?)
$A22D POP AF          ;восстанавливает регистры
$A22E RET             ;выход из прерывания


<======================================>


;$A241: Keyboard query - $A25B(+2)

??? В зависимости от 5-го бита ячейки $C4B3 опрашивает или нет пробел. Возврат - в флаге Z ???

                    ;read port $BFFE (checks space?)
$A248 EX AF, AF'
$A249 CALL $C573    ;????
$A24C EX AF, AF'  
$A24D LD B, A       ;Копирует в B значение, считанное из порта
$A24E LD A,($C4B3)
...

----------------------
;Variables:

;$A25C (1) : sound to play
;$A25E (1)
----------------------

;$A25F: Play sound or wait - $A271

$A25F XOR A
      LD ($C4B9),A  ;clear flag that interrupt has happened
      LD A,$FE
      LD I,A
      EI            ;enable interrupts
      CALL $A272    ;play sound, returns if nothing played or interrupt has happened
$A26B LD A,($C4B9)
      AND A
      JR Z,$A26B    ;wait until interrupt flag will be set
$A271 RET

;----------------------
;$A272: Play sound  - $A2C9

$A272 LD HL,$A25C
      LD A,(HL)     ;read variable
      LD (HL),$00
      LD HL,$A25E
      AND A
      JR Z,$A28D    ;jump if reg A is 0
      LD B,A        ;save to B
      LD A,(HL)     ;read variable
      AND A
      JR Z,$A286    ;jump if reg A is 0
      CP B          ;compare
      JR C,$A28D
$A286 LD A,B
      LD (HL),A
      LD A,$FF
      LD ($A25D),A  ;this value
$A28D LD A,(HL)
      AND A
      RET Z         ;return if reg A is 0
      ADD A,A       ;*2
      LD C,A
      LD B,$00      ;into BC - offset
      LD HL,$A2C8   ;table base
      ADD HL,BC     ;table entry
      LD E,(HL)
      INC HL
      LD D,(HL)     ;read two bytes into DE
      LD HL,$A25D
      INC (HL)      ;increment
      LD C,(HL)     ;into C
      EX DE,HL
      ADD HL,BC
      LD A,(HL)     ;read frequency
      CP $FF
      JR NZ,$A2AC
      XOR A
      LD ($A25E),A  ;if $FF then save 0
$A2AB RET           ;and return
;play the sound, reg A holds the frequency
$A2AC LD H,A        ;save reg A
      LD L,$60      ;how many up-down sound cycles
$A2AF LD A,$10
      OUT ($FE),A   ;out to sound port?
      LD B,H        ;B is a delay for high sound amplitude
$A2B4 LD A,($C4B9)
      AND A
      RET NZ        ;return if ($C4B9) is 0
      DJNZ $A2B4    ;loop so sound is played
      XOR A
      OUT ($FE), A  ;drop the sound amplitude
      LD B,H        ;B is a delay for low sound amplitude
$A2BF LD A,($C4B9)  ;flag to exit
      AND A
      RET NZ
      DJNZ $A2BF    ;loop so sound is played
      DEC L         ;decrement up-down sound cycles
      JR NZ,$A2AF   ;keep playing the sound
$A2C9 RET


;----------------------
;$A378: Send hard-coded values to AY chip - $A397

$A378 XOR A
$A379 LD ($A25E),A  ;???
$A37C LD D,$3F
$A37E LD A,$07
$A380 CALL $A38E    ;these bytes to AY
$A383 LD D, $00
$A385 INC A
$A386 CALL $A38E    ;these bytes to AY
$A389 INC A
$A38A CALL $A38E    ;these bytes to AY
$A38D INC A
;fall to
;secondary entry point
;sends value of reg A into port $FFFD (AY sound chip)
;  and value of reg D into port $BFFD (AY sound chip)
$A38E LD BC,$FFFD
$A391 OUT (C),A     ;
$A393 LD B,$BF
$A395 OUT (C),D     ;
$A397 RET           ;ret

;----------------------
;$A44C: Screen scroll if we are riding a platform, or falling down - $A479 (+2)

$A44C LD A,($C4BF)  ;get jumping/falling frame
      LD B,A
      LD A,($C4B6)  ;index of a platform we are riding on
      OR B
      RET NZ        ;ret if at least one of them is not 0
      LD A,($C4EB)  ;vertical shift
      AND A
      RET Z         ;ret if 0
      DEC A         ;dec
      JR Z,$A469    ;if became 0, go
      DEC A         ;dec again
      JR Z,$A472    ;if became 0, go
$A460 CALL $C9CF    ;move screen down
      LD HL,$C3AA   ;vertical coord of player in pixels
      DEC (HL)      ;dec it
      DEC (HL)      ;dec it
$A468 RET
$A469 CALL $C991    ;move screen up
      LD HL,$C3AA   ;vertical coord of player in pixels
      INC (HL)      ;increment
      INC (HL)      ;increment
$A471 RET
$A472 LD A,($C3AA)  ;vertical coord
      CP $58        ;compare
      JR C,$A469
$A479 JR $A460

;----------------------
;$A47B: prepare a game screen - $A4DB (and falls further)

$A47B LD A,R
$A47D AND $07
$A47F INC A
$A480 LD C,A        ;reg C contains lower 3 bytes of R incremented
$A481 XOR A         ;A=0
$A482 LD ($C4B8),A  ;???
$A485 LD ($C4B1),A  ;???
$A488 LD ($A25C),A  ;???
;outer loop
$A48B LD ($C398),A  ;current level
$A48E CALL $A4EB    ;find data structures for current level
$A491 LD B,C        ;copy C to B, now it is inner loop counter
;inner loop
$A492 PUSH BC       ;save
$A493 CALL $A53C    ;????
$A496 POP BC        ;restore
$A497 DJNZ $A492    ;end of inner loop
$A499 LD A,($C398)  ;
$A49C INC A         ;increment this variable
$A49D CP $09        ;check number of loops
$A49F JR NZ,$A48B   ;repeat outer loop

$A4A1 CALL $A8B5    ;draw game screen border
$A4A4 CALL $C097    ;reset and print game score

$A4A7 XOR A         ;will fill memory with 0
$A4A8 LD HL,$C398   ;starting from this address
$A4AB LD B,08       ;this amount of bytes
$A4AD CALL $C512    ;do it!

;set current weapon to 1, and weapon power to 1
$A4B0 INC A         ;will fill memory with 1
$A4B1 LD B,$0A      ;amount of bytes
$A4B3 CALL $C512    ;HL=$C3A0, call fill procedure

$A4B6 CALL $C113    ;draw current weapon and print all weapon's power
$A4B9 CALL $C0DC    ;reset diamonds counter and their indicator
$A4BC CALL $C19E    ;reset elemental counter and their indicator
$A4BF LD B,0        ;elemental kind (air)
$A4C1 CALL $A67D    ;draw central elemental sprite

$A4C4 LD A,4
$A4C5 LD ($C3A7),A  ;?? lives ??

$A4C9 LD HL,$C325   ; ?
$A4CC LD ($C323),HL
$A4CF LD A,($C4DA)  ;get flag to skip "get ready" message and delay
$A4D2 AND A         ;check for 0
$A4D3 RET NZ        ;exit, if not 0
$A4D4 LD A,1
$A4D6 LD ($C397),A  ;number of message, arg for $C1B5
$A4D9 CALL $C1B5    ;print the message
;execution falls to fixed length pause

----------------------
$A4DC: fixed length pause - $A4DF
sets pause values in A,B,C, then falls to $A4E1

----------------------
$A4E1: Pause - $A4EA:

time delay value - A,B,C
just moves value from A to D, and falls to

$A4E2: second entry point - D,B,C
Just empty cycles.

----------------------
$A4EB: Find data lists for current level - $A539 (+2)
Input: ($C398) current level
Output: variables ($C4D0), ($C4CC), ($C4D2), ($C4CE), ($C4CA), ($A94E)

$A4EB LD HL,$DE52    ;some specific area in memory
      LD DE,$000A    ;search step
      CALL $A832     ;search 0 in memory
      LD ($C4D0),HL  ;store the result

$A4F7 LD HL,$E28B    ;dynamic object coord/speed/time table for level 1
      LD DE,$0009    ;entry size
      CALL $A832     ;scan and find a beginning of a list for current level
      LD ($C4CC),HL  ;store the result

$A503 LD HL,$DE2E    ;some table for level 1
      LD DE,$0003    ;entry size
      CALL $A832     ;scan and find a beginning of a list for current level
      LD ($C4D2),HL  ;store the result

$A50F LD HL,$E17A    ;some table for level 1
      LD DE,$0006    ;entry size
      CALL $A832     ;scan and find a beginning of a list for current level
      LD ($C4CE),HL  ;store the result
      CALL $A844     ;reset 7-th bits

$A51E LD HL,$DF05    ;some table for level 1
      LD DE,$0005    ;entry size
      CALL $A832     ;scan and find a beginning of a list for current level
      LD ($C4CA),HL  ;store the result
      CALL $A844     ;reset 7-th bit

$A52D LD HL,$DDC5    ;teleport table for level 1
      LD DE,$0002    ;entry size
      CALL $A832     ;scan and find a beginning of a list for current level
      LD ($A94E),HL  ;store the result
$A539 JP $A844       ;shortcut for CALL $A844 + RET


----------------------
$A53С: ??? - $A58B

----------------------
$A58D: Graphics init for new level ??? 

$A58D XOR A
      LD ($C397),A   ;нулевой номер сообщения
      CALL $A378     ;send some values to AY chip
      LD A,($C4B1)   ;???
      AND A          ;compare with 0
$A598 JP NZ,$A62A    ;если не 0

$A59B LD A,($C399)   ;??? current elemental
      ADD A,A
      ADD A,A        ;multiply to 4
      LD L,A
      LD H,0         
      LD DE,$A66D    ;?????
      ADD HL,DE      ;итого: HL=($C399)*4 + $A66D
      LD DE,$C4A6
      LD BC,4
      LDIR           ;move 4 bytes
      LD B,A         ;row number = 4*($C399)
$A5B0 CALL $A67D     ;draw elemental central sprite

$A5B3 XOR A
      LD ($C4AF),A   ;player's initial state (sprite)
      LD H,A
      LD L,A
      LD ($C4AA),HL  ;??
      LD ($C4AC),HL  ;??
      LD HL,$2904    ;?? initial value for timer ??
      LD ($C4D4),HL  ;?? store
$A5C5 CALL $C19E     ;reset elemental counter and indicator
      LD A,($C398)   ;current level
      CP $08
      JR Z,$A62A
      LD A,($C399)
      INC A
      LD ($DC18),A
      DEC A
      JR Z,$A617
      LD A,$46       ;attribute value
      LD ($C32F),A
$A5DE CALL $A85A     ;clear dynamic game window 
      LD A,$05
      LD ($A645),A

$A5E6 LD B, $04
$A5E8 LD HL, $C39C
;loop
$A5EB LD A, (HL)
$A5EC INC HL
$A5ED AND A
$A5EE JR Z, $A612
$A5F0 PUSH HL
$A5F1 PUSH BC
$A5F2 LD A,B
$A5F3 SUB $04
$A5F5 NEG
$A5F7 LD DE,$A646    ;to this location
$A5FA CALL $A65C     ;copy 5 bytes (elemental name? scene name?)
$A5FD LD HL,$A644    ;script with words to draw
$A600 CALL $C1FC     ;draw a set of words on screen
$A603 LD HL, $A645
$A606 INC (HL)
$A607 INC (HL)
$A608 CALL $E6DC     ;play sound
$A60B LD A, $02
$A60D CALL $A4E1     ;pause
$A610 POP BC
$A611 POP HL
$A612 DJNZ $A5EB     ;jump to loop start

$A614 LD A,($C399)
$A617 LD DE,$DC01    ;to this location
$A61A CALL $A65C     ;copy 5 bytes
$A61D CALL $C0B5     ;draw symbol ?
$A620 CALL $AA3D     ;get value from table into reg A
$A623 JR NZ, $A62A   ;if not 0, jump
$A625 LD A, $02
$A627 CALL $C1AD     ;prepare to print message on screen
;lots of jumps here from other places
$A62A CALL $AA3D     ;get value from table into reg A
$A62D LD ($C4B8),A
$A630 CALL $A4EB     ;some search in memory
$A633 CALL $D920     ;prepare sprite-set for level's blocks
$A636 CALL $A753     ;unpack current level into area starting at $9D72
$A639 CALL $A934     ;find all teleports blocks
$A63C LD A, ($C39B)
$A63F AND A
$A640 RET NZ
$A641 JP $A69F       ;.

... some data here ...

;entry point
;Param: DE
;Param: reg A 
;copy to memory starting from DE 5 bytes from $DDB1 + 5*A
$A65C LD B,A
$A65D ADD A,A
$A65E ADD A,A
$A65F ADD A,B        ; A = A * 5
$A660 LD L, A
$A661 LD H, $00      ; HL = param * 5
$A663 LD BC, $DDB1   ; base
$A666 ADD HL, BC     ; add offset
$A667 LD BC, $0005   ; number of bytes
$A66A LDIR           ; move
$A66C RET
.............
----------------------

$A66D 


----------------------
$A67D: Draw elemental central sprite 2*2 (air, fire, ...)

from the rightmost part of a pixel area, which is hidden behind
black attributes, graphics is copied into visible area horizontally

Input param: B - line number, identifies elemental sprite

$A67D LD C,$1F       ;last column
$A67F CALL $C2D5     ;calculate pixel area address
$A682 EX DE,HL       ;move it to DE
$A683 LD DE,$508F    ;hardcoded address in video mem pixel area
$A686 CALL $A68B     ;call first time
$A689 LD E,$AF       ;DE=$50AF, another hardcoded address, 8 lines below
;first time a call is made here, second time execution falls here
; 2 8*8 pixel blocks, one under another, located at HL, are copied horizontally at DE
$A68B LD C,$02       ;block counter
$A68D LD B,$08       ;8 pixel lines
      PUSH DE        ;store
;copy loop
$A690 LD A,(HL)
      LD (DE),A      ;copy
      INC H          ;next source pixel line
      INC D          ;next dest pixel line
$A694 DJNZ $A690     ;repeat for all 8 pixel lines
$A696 POP DE         ;restore DE
      CALL $C2CA     ;HL was pointing to last line of first block 
                     ;recalc so it points to first line of block just below
      INC E          ;DE moves to next block to the right
      DEC C
      JR NZ,$A68D    ;repeat
$A69E RET            ;exit.

----------------------
$A6C8: init for new level

$A6C8 LD A,($C4B8)   ;??
      AND A          ;check if 0
      LD A,$C5       ;ether this constant
      JR Z,$A6D2
      LD A,$41       ;or this
$A6D2 LD ($C3AF), A  ;go here
      CALL $C4EE     ;clear list of colliding objects and list of visible objects
      LD A,R
      AND $07
      LD H,A
      LD ($C4D6),HL  ;init random value
      LD A,$50
      LD ($C3A9),A   ;??
      LD A,$04
      LD ($C4C0),A   ;??
      LD ($C4C6),A   ;??
      LD A,$32
      LD ($C4BD),A   ;??
      LD ($C4BC),A   ;??
      CALL $A72A     ;additional clear for level
      LD C,$06
      LD HL,($C4A6)  ;?? initial coordinates of player on a screen ??
      LD ($C3AA),HL  ;current coordinates of player on screen, in pixels
      LD HL,$C4A8    ;??
      LD DE,$C4E8    ;??
      LDIR
      CALL $C819     ;calculate coordinates
      CALL $C0C2     ;draw current number of lives
      CALL $C113     ;draw weapon
      LD A,($C398)   ;current level
      CP $08
$A716 RET NZ
      LD A, ($C4C3)  ;??
      LD ($C398),A   ;this is a level code
      LD A,$07
      LD ($C4B0),A   ;and this value here
      XOR A          ;message number
      CALL $C1AD     ;print message
      POP BC
$A727 JP $A193

;additional proc,
$A72A LD A,($C4AF)   ;player's state
      AND $80        ;reset all except direction
      LD ($C4AF),A   ;write back
      XOR A
      LD ($C4B6), A  ;??
      LD ($C4BA), A  ;counter of dynamic colliding objects
      LD ($C4BB), A  ;??
      LD ($C4BE), A  ;??
      LD ($C4B0), A  ;??
      LD ($C4C1), A  ;??
$A745 LD HL,($C4CC)  ;load address of list of script-moved objects (clouds)
      LD BC,$0009    ;structure size
$A74B LD A,(HL)      ;first byte (status)
      AND $9F        ;apply mask
      RET Z          ;exit if list end was reached
      LD (HL), A
      ADD HL,BC      ;move to next structure
A751$ JR $A74B

----------------------
$A753: Unpack level block data into area starting at $9D72 - $A769 (+2)

$A753 LD HL,$6E5E    ;start of packed level data
      LD A,($C398)   ;number of current level
      AND A
      JR Z,$A765     ;if 0, then nothing to search
      LD B,A         ;number of level will be a counter
$A75D LD A,(HL)
      INC HL
      CP $FF
      JR NZ,$A75D    ;scan until $FF (end of packed level data) will be found
      DJNZ $A75D     ;loop through levels until required will be found
$A765 EX DE,HL       ;DE will point to packed data for current level
      CALL $A7A4     ;unpack low half-bytes
      JP $A7FC       ;unpack high half-bytes and return

----------------------

$A76C: Unpack some bits and check if they are 0  - $A798

Params: reg C: how many bits to get. Bits are counted in descending direction (from high to low)
        DE: memory address
        ($C4C8) : shift accumulator

Return values:
        reg A - requested bits (shifted to low bits)
        flag Z if all these bits are 0

$A76C PUSH HL        ;save
      PUSH BC        ;save
      LD A,(DE)
      LD H,A         ;H <- (DE)
      INC DE         ;increment
      LD A,(DE)
      LD L,A         ;L <- (DE)
      DEC DE         ;back
      LD A,($C4C8)   ;get "shift accumulator"
      ADD A,C        ;add
      LD B,A         ;save
      CP $08         ;if more than 8 bits are required
      JR C,$A780     ;then move DE
      SUB $08
      INC DE
$A780 LD ($C4C8),A   ;save "shift accumulator"

;shift HL value to the right, throwing away all bits except requested high bits
      LD A,B         ;restore
      SUB $10
      NEG            ;A = $10 - A
      LD B,A         ;how many shifts
$A789 SRL H          ;
      RR L           ;shift HL right
$A78D DJNZ $A789     ;loop

;create a mask containing 1 bits
$A78F LD B,C         ;how many low bits to set
      XOR A          ;all bits 0
$A791 SCF            ;set CF
      RLA            ;rotate reg A left, CF goes to low bit
$A793 DJNZ $A791     ;loop
      AND L          ;mask (affects ZF)

      POP BC         ;restore
      POP HL         ;restore
$A798 RET

----------------------
$A799: Compare HL with value - $A7A3

$A799 PUSH HL
      PUSH BC
$A79B LD BC,$FEBD    ;this value is not hard-coded, it is injected externally
$A79E AND A
      SBC HL,BC
      POP BC
      POP HL
$A7A3 RET

----------------------
$A7A4: Unpack low half-bytes from data pointed by DE into area $9D72 - $A7FB

Params: DE points to packed data
Format:
        1 bit - if 0 then next 3 bits define how many 0 values to write
                if 1 then next 4 bits are value to write into memory
                if value repeats two times, then third value is a counter to write the same value into memory

$A7A4 LD HL,$A132
      LD ($A79C),HL  ;modify code of compare proc, set limit
      XOR A
      LD ($C4C8),A   ;init "shift accumulator"
      LD HL,$9D72    ;destination (temp area)
$A7B1 LD C,$01
      CALL $A76C     ;unpack 1 bit
      JR Z,$A7EF     ;if 0, jump to "write repeating zeroes"
      LD C,$04
      CALL $A76C     ;unpack 4 bits into A
$A7BD LD (HL),A      ;put
      LD B,A         ;save
      INC HL
      CALL $A799     ;compare with $A132
      JR NC,$A7FA    ;exit if done
      LD C,$01
      CALL $A76C     ;unpack 1 bit
      JR Z,$A7EF     ;if 0, jump "write repeating zeroes"
      LD C,$04
      CALL $A76C     ;unpack 4 bits into A
      CP B           ;compare with saved
$A7D2 JR NZ,$A7BD    ;if they are different, just loop
;two same values means that next value is a counter of repeating value
;this same value is in regs B and A
$A7D4 LD (HL),A      ;put
      INC HL         ;to next addr
      LD C,$04
      CALL $A76C     ;unpack 4 bits into A - counter
      CALL $A799     ;compare with $A132
      JR NC,$A7FA    ;exit if done
      LD C,$0F

;loop to write the same value into memory. Value is reg B, counter is reg A, amount of bits in counter is reg C
$A7E2 DEC A          ;decrement counter
      AND C
      JR Z,$A7B1     ;exit loop if 0
$A7E6 LD (HL),B      ;write value
      INC HL         ;move to next addr
      CALL $A799     ;compare with $A132
      JR NC,$A7FA    ;exit if done
      JR $A7E2       ;loop

;unpack 3 bits as counter of how many 0 values to write, then jump to write those 0
$A7EF LD C,$03
      CALL $A76C     ;unpack 3 bits into reg A - counter of 0 bytes to write
      LD B,$00       ;value 0 to write
      LD C,$07       ;mask (since only 3 bits in A are real)
      JR $A7E6       ;write into memory and

$A7FA INC DE         ;exit
$A7FB RET

----------------------

$A7FC: Unpack high half-bytes and combine with existing memory data at $9D72 - $A830 (+2)

Params: DE - address to unpack from
        HL - memory area to update
Format: if bit 7 is 1, then set the same single high bit for a sequence of bytes
        if bit 7 is not set, skip bytes


$A7FC LD HL,$9D72    ;address of unpack area
$A7FF LD A,(DE)      ;read byte
      INC DE
      CP $FF
      RET Z           ;if $FF then exit
      BIT 7,A         ;check high bit
      JR Z,$A826      ;if not set, jump

;set the same high bits for a sequence of bytes
;bits 5+6 define position of bit 1 from the left (high bits), bits 0-4 define for how many bytes
$A808 LD C,A         ;save into reg C
      AND $60         ;mask, keeping bits 5 and 6, clear all other bits
      RLCA
      RLCA
      RLCA            ;rotate left, so bits 5 and 6 will move to bits 0 and 1
      INC A           ;increment, since we will start from carry flag
      LD B,A          ;this is a shift counter
      XOR A           ;clear to init
      SCF             ;set carry flag, it will go to high bit
$A812 RRA
      DJNZ $A812      ;shift a 1 bit to the right as many as counter
      LD B,A          ;save
      LD A,C          ;restore initial value
      AND $1F         ;mask: clear bits 7,6,5, it will be a byte counter
;loop
$A819 LD C,A          ;save loop counter
      LD A,(HL)       ;read from memory
      OR B            ;combine with reg B
      LD (HL),A       ;write back
      INC HL          ;to next addr
      LD A,C          ;restore loop counter
      DEC A           ;decrement it
      AND $1F
      JR NZ, $A819    ;loop
$A824 JR $A7FF       ;big loop

;skip some bytes, bits 0-6 define how many bytes to skip
$A826 AND $7F        ;clear high bit
      JR NZ,$A82C
      LD A,$80        ;if 0 then set $80
$A82C LD C,A
      LD B,$00        ;reg BC contain offset
      ADD HL,BC       ;add to dest memory addr in HL
$A830 JR $A7FF       ;back to big loop

----------------------
$A832: Find a start of an entry list for current level  - $A843
Scans the list until first byte of list entry will be 0, which is an end indicator
Input: HL - initial addr; DE - search step. ($C398) - current level.
Output: HL - addr of a beginning of a list

$A832 LD A,($C398)   ;current level, shows how many lists should we skip
      AND A
      RET Z          ;exit immediatelly if 0
$A837 LD B,A         ;store in B, loop counter
;outer loop
;inner loop HL=HL+DE until (HL) will be 0
$A838 LD A,(HL)      ;read first byte
      AND A
      JR Z,$A840     ;go if 0 was found, we reached the end of a list for one level
      ADD HL,DE      ;add list entry size, thus moving to next entry
$A83D JP $A838       ;end of inner loop
      INC HL         ;increment, so now HL is looking at the beginning of next list
$A841 DJNZ $A838     ;decrement B, end of outer loop
$A843 RET          

----------------------
$A844: Memory modification, reset 7-th bit until 0 is found - $A857 (+2)

Input: HL - initial addr. DE - step

$A844 LD A,($C4B1)
$A847 LD B,A
$A848 LD A,($C4B8)
$A84B OR B
$A84C RET NZ         ;if ($C4B1) or ($C4B8) are not 0, exit immediatelly
$A84D LD A,(HL)
$A84E AND A
$A84F RET Z          ;exit if 0 is found
$A850 CP $80
$A852 JR Z,$A856     ;if $80, then don't reset bit 7
$A854 RES 7,(HL)     ;otherwise, reset it
$A856 ADD HL,DE      ;add step to the addr
$A857 JP $A844       ;repeat the loop (why not JP $A84D ?)


----------------------
$A85A: Clear dynamic game window - $A886
Params: reg A - attribute value

$A85A EX AF,AF'      ;save reg A

;clear video memory pixel area rectangle, $19*$10 blocks of 8*8 pixels
$A85B LD D,$10       ;number of 8*row groups (80 rows at all)
      LD HL,$4043    ;from this address (video mem pixel area)
;clear 8 lines in video memory
$A860 XOR A          ;value
      LD E,L         ;save
      LD C,$08       ;line counter
$A864 LD B,$19       ;this amount of bytes
      CALL $C512     ;fill memory
      LD L,E         ;restore
      INC H          ;to next line
      DEC C          ;decrement line counter
      JR NZ, $A864   ;jump to loop start
      CALL $C2CA     ;calc start address of next line
      DEC D          ;decrement 8*row counter
$A872 JR NZ, $A860   ;jump to loop start

$A874 EX AF, AF'     ;restore reg A

;fill attribute area with value of reg A
$A875 LD HL, $5843   ;address in attrib area
      LD C, $10      ;number of attribute lines
      LD DE, $0007   ;$07 + $19 = $20, whole attrib screen line
$A87D LD B, $19      ;number of attrib blocks in line
      CALL $C512     ;fill memory
      ADD HL, DE     ;to next line
      DEC C          ;dec line counter
      JR NZ, $A87D   ;loop again
$A886 RET

----------------------
$A8B5: Clear screen and draw game border - $A8D2 (+2)

Game border is stored at $EBFD.
Empty parts are packed: 0 then quantity of bytes

$A8B5 XOR A          ;screen attribute will be 0
      CALL $EAEE     ;clear screen
      LD HL,$EBFD    ;game border address
      LD DE,$4000    ;video mem pixel area start
;loop transferring border to video mem
$A8BF LD A,(HL)      ;get byte
      INC HL         ;increment source pointer
      AND A          ;check for 0
      JR Z,$A8CC     ;special handling for 0
      LD (DE),A      ;just put in video memory
      INC DE         ;increment video memory pointer
$A8C6 LD A,D         
      CP $5B         ;check for pixel area end
      JR NZ $A8BF    ;repeat otherwise
      RET            ;exit if that's all
$A8CC LD B,(HL)      ;read amount of 0 bytes to draw
      INC HL
$A8CE LD (DE),A      ;small loop to set 0 to video mem
      INC DE
      DJNZ $A8CE     ;end of small loop
$A8D2 JR $A8C6       ;back to main loop


----------------------

$A8D4 ?? Decrement timer, print hurry up message ?? - $A90F

$A8D4 LD A,($C4B0)   ;??
      CP $04
      JR Z,$A8DD
      AND A
      RET NZ         ;exit if not 0 or 4
;jumps here is A is either $04 or $00
$A8DD LD HL,($C4D4)  ;load
      DEC HL         ;decrement
      LD ($C4D4),HL  ;and store back
      LD A,H
      OR L           ;check if HL = 0
      JR Z,$A900     ;go if it is
      LD A,H
      AND A
      JR Z,$A8F4     ;go if H=0
      CP $0A
      RET NZ         ;exit, if not $0A
      LD A,$05       ;message number
      JP $C1AD       ;prepare to print message on a screen and exit
;this code is executed if H=0
$A8F4 LD A,L
      CP $32         ;check if L = $32
      LD A,$05       ;this will be the message if it is greater or equals
      JR NC,$A8FD
      LD A,$06       ;if less than $32, this will be the message code
$A8FD JP $C1AD       ;prepare to print message on a screen and exit
;this code is executed if HL = 0, ?? player is dying ??
$A900 LD A,$06       ;message number
$A902 CALL $C1AD     ;prepare to print the message
      LD A,$05       ;put this value ???
      LD ($C4B0),A   ;here ??
      LD A,$01       ;and this value ??
      LD ($A25C),A   ;here ??
$A90F RET

----------------------
$A910: Handle game status specific stuff - $A931 (+2)

$A910 LD A,($C4B0)   ;game state
      AND A          ;check if 0 - normal game state
      RET Z          ;return, nothing to do
$A915 DEC A
      JP Z,$ADFB     ;go if status = 1, death
      DEC A
      JP Z,$ADFB     ;go if status = 2, death
      DEC A
      JP Z,$ADC6     ;go if status = 3, death, fall down
      DEC A
      JP Z,$A96A     ;go if status = 4
      DEC A
      JP Z,$ADFB     ;go if status = 5, death
      DEC A
      JP Z,$AF33     ;go if status = 6
      DEC A
      JP Z,$AA70     ;go if status = 7
$A931 JP $AC0F       ;go if status > 7

----------------------
$A934: Locate all level blocks with bit 5 set and put their addresses to location starting at $A952 - $A94D

$A934 LD HL,$9D72    ;current level map
      LD DE,$A952    ;will collect blocks' addresses here
      LD BC,$03C0
$A93D BIT 5,(HL)     ;check bit 5
      JR Z,$A947
      LD A,L
      LD (DE),A      ;put low byte here
      INC DE         ;move
      LD A,H
      LD (DE),A      ;put high byte here
      INC DE         ;move
$A947 INC HL
      DEC BC
      LD A, B
      OR C
      JR NZ,$A93D    ;loop
$A94D RET

----------------------
$A94E (2) : teleport table address for current level
$A950 (2) : address of teleport block we are currently standing on
$A952: Area to store teleport block addresses, 2 bytes for each teleport block

----------------------
;$A96A: Teleporting - AA3A (+2)

$A96A XOR A
      LD ($C4B0),A   ;??
      LD A,($C4AF)   ;player's status/sprite number
      BIT 6,A        ;check if player is sitting
      RET Z          ;return if not
      LD BC,($A950)  ;teleport block address
      LD HL,$A952    ;teleport table base addr

;find teleport in a list
      XOR A          ;teleport counter initial value
A97C: LD E,(HL)      ;first byte here
      INC HL
      LD D,(HL)      ;second byte here
      INC HL
      EX DE,HL
      AND A
      SBC HL,BC      ;compare
      JR Z,$A98A     ;go if equals, we found it
      EX DE, HL
      INC A          ;increment teleport counter
      JR $A97C       ;loop

;reg A contains teleport number
A98A: ADD A,A        ;*2
      LD C,A
      LD B, $00      ;make it as offset
      LD HL,($A94E)  ;?? load base address from here, teleport target table ?? example value: $DDE4
      ADD HL,BC      ;add offset, reg HL now contains full addr
      LD D,(HL)      ;read first byte, example value: $01
      INC HL
      LD E,(HL)      ;and second byte, example value: $00
      LD ($A964),HL  ;?? store HL here
      LD ($A968),DE  ;?? store DE here
      LD A,D         ;copy
      AND $C0        ;mask
      RET NZ         ;has bits, go away
      BIT 5,E        ;?? check this bit
      JR Z,$A9B6     ;can go
      LD A,($C4B8)   ;??
      AND A
      JR NZ,$A9B6    ;can go
      LD A,($C3A8)   ;elemental counter
      CP $06         ;check if all elementals are collected
      JR Z,$A9B6     ;check further
      LD A,$03       ;message number: "elemental required"
      JP $C1AD       ;can't go in teleport, print message and return
$A9B6 LD A,$01
      LD ($C4B1),A   ;??
      BIT 4,E
      JP NZ,$AA79    ;?? in debugger it is called when teleporting to boss
      BIT 3,E
      JR Z,$A9F9
      LD A,($C4B8)   ;??
      AND A
      JR NZ,$A9CF    ;check further
      LD A,$0A       ;message number: "no entry here"
      JP $C1AD       ;can't go in teleport, print message and return
$A9CF LD A,E
      DEC A
      AND $07        ;mask
      LD C,A         ;make into offset
      EX AF,AF'
      LD B,$00
      LD HL,$AA4A    ;base address
      ADD HL,BC      ;add offset to base
      LD A,(HL)      ;load value
      CP $03
      JR Z,$A9EC     ;go if equals
      CALL $AA40
      JR Z,$A9EB
      LD A,$0F
      CALL $C1AD     ;can't go, print message
$A9EA RET            ;and return
$A9EB LD A,C
$A9EC LD ($C399),A
      EX AF,AF'
      LD ($C398),A
      CALL $AA52     ;blink the game screen
      JP $A13C

;teleporting
$A9F9 LD A,E
      AND $07
      LD ($C398),A   ;new level
      LD A, D
      PUSH AF
      CALL $AA52     ;blink the game screen
      CALL $A58D     ;init graphics for new level
      POP AF
      DEC A
      ADD A, A
      LD L, A
      LD H, $00
      LD BC, $A952
      ADD HL, BC
      LD E, (HL)
      INC HL
      LD D, (HL)
      EX DE, HL
      CALL $C7D8
      LD DE, $7058
      DEC H
      DEC H
      LD A, L
      SUB $06
      JR NC, $AA29
      ADD A, A
      ADD A, A
      ADD A, A
      ADD A, A
      ADD A, E
      LD E, A
      XOR A
AA29: LD L, A
      LD ($C4A8), HL
      LD ($C4A6), DE
      LD HL, $0000
      LD ($C4AA), HL
      LD ($C4AC), HL
AA3A: JP $A6D5

----------------------
;$AA3D: Read value from table $C39C   - $AA49

Param/Var:  ($C399) - ? offset

$AA3D LD A,($C399)   ;param
$AA40 LD C,A
$AA41 LD B,$00       ;into CBC
$AA43 LD HL,$C39C    ;base
$AA46 ADD HL,BC      ;add offset
$AA47 LD A,(HL)      ;read byte
$AA48 AND A
$AA49 RET

----------------------
$AA52: Blink the game screen, we are teleporting - $AA6F

AA52: CALL $A378
AA55: LD B, $07
AA57: LD A, $FE
AA59: LD I, A
AA5B: EI
AA5C: HALT
AA5D: LD A, $FE
AA5F: LD I, A
AA61: EI
AA62: HALT
AA63: LD A, B
AA64: OR $40
AA66: CALL $A875
AA69: DEC A
AA6A: AND $07
AA6C: LD B, A
AA6D: JR NZ, $AA57
AA6F: RET

----------------------
AA70: LD HL, ($A964)
AA73: LD DE, ($A968)
AA77: JR $AAC1


----------------------
AA79: LD A, ($C4B8)
AA7C: AND A
AA7D: JR Z, $AA87
AA7F: LD A, ($C398)
AA82: CP $07
AA84: RET C
AA85: JR $AA8D
AA87: DEC HL
AA88: BIT 7, D
AA8A: RET NZ
AA8B: SET 7, (HL)
AA8D: LD A, D
AA8E: CP $20
AA90: JP Z, $AD95
AA93: CALL $AB93
AA96: LD BC, $0008
AA99: ADD HL, BC
AA9A: LD A, ($C3A0)
AA9D: CP $03
AA9F: JR Z, $AAAB
AAA1: LD ($C3A1), A
AAA4: EX AF, AF'
AAA5: LD A, D
AAA6: CP $09
AAA8: JR NC, $AAB3
AAAA: EX AF, AF'
AAAB: BIT 7, (HL)
AAAD: JR Z, $AABE
AAAF: CP $03
AAB1: JR Z, $AAC1
AAB3: LD HL, $C3A0
AAB6: LD A, (HL)
AAB7: LD ($C3A1), A
AABA: LD (HL), $03
AABC: JR $AAC1

----------------------
;$ACEB: Check if player doesn't go out of the screen - $AD2A

$ACEB LD IX,$C3B5    ;colliding dynamic objects list base addr
      LD HL,$C4B3    ;currently pressed key addr
      LD B,(IX+$03)
      LD A,(IX+$02)  ;coord
      CP $C0         ;compare
      JR C,$AD04     ;go if less
      LD (IX+$02),$C0;otherwise, set this value
      SET 0,B        ;and this bit
      JR $AD0E
$AD04 CP $1C         ;compare
      JR NC,$AD0E    ;go if greater
      LD (IX+$02),$1C;otherwise, set this value
      RES 0,B        ;and this bit
$AD0E LD A,(IX+$01)  ;coord
      CP $12         ;compare
      JR NC,$AD1D    ;go if greater or equal
      LD (IX+$01),$12;otherwise, set this value
      RES 1,B        ;and this bit
      JR $AD27
$AD1D CP $60         ;compare
      JR C,$AD27     ;go if less
      LD (IX+$01),$60;otherwise, set this value
      SET 1,B        ;and this bit
$AD27 LD (IX+$03),B  ;store
$AD2A RET

----------------------

AD2B: LD A, ($C4C5)
AD2E: AND A
AD2F: JR Z, $AD36
AD31: DEC A
AD32: LD ($C4C5), A
AD35: RET

----------------------
;$ADC6: Death, fall down - $ADFA

$ADC6 LD A,($C398)   ;current level
      CP $08
      JR NZ,$ADD4
      LD A,($C4C2)   ;??
      AND A
      CALL Z,$ACEB   ;check that player doesn't go out of screen
$ADD4 LD A,($C3AA)   ;coord
      CP $90         ;compare
      JR C,$ADE3     ;go if less
      LD HL,$C4C4    ;??
      DEC (HL)       ;decrement
      RET NZ         ;if not 0 yet, returm
      JP $AEB6
$ADE3 ADD A,$04      ;add to coord
      LD ($C3AA),A   ;write back
      LD HL,$C4BF    ;current jumping/falling frame addr
      LD (HL),$01    ;write this constant here
      CP $90         ;compare
      RET C          ;return if less
      LD A,$90
      LD ($C3AA),A   ;otherwise, fixed constant
      LD A,$38
      LD ($C4C4),A   ;??
$ADFA RET

----------------------
$ADFB: Death handling - AE7A

$ADFB LD A,($C398)   ;current level
      CP $08
      JR NZ,$AE0D
      LD A,($C4C2)   ;??
      AND A
      CALL Z,$ACEB   ;check that player doesn't go out of screen
      XOR A
      LD ($C397),A   ;reset number of message
$AE0D LD A,($C4C1)   ;?? dying frame ??
      LD L,A
      LD H,$00       ;make it as an offset
      LD BC,$AE83    ;base address
      ADD HL,BC      ;add offset
      LD A,(HL)      ;load value from table - vertical coord change
      CP $80         ;end of table marker
      JR Z,$AE7B     ;if end of table reached, go away
      LD DE,($C3AA)  ;coords
      ADD A,E        ;add to vertical coord
      LD E,A
      LD BC,$1818    ;size of player
      PUSH DE        ;save
      CALL $C858     ;scan rectangle
      POP DE
      JR NZ,$AE30    ;don't update the coord if player's body hits some level block
      LD ($C3AA),DE  ;store coord back
AE30: LD HL,$C4AF    ;player's sprite number, direction and sitting
      LD A,$FE       ;value -2
      BIT 7,(HL)     ;check direction bit
      JR Z,$AE3B
      LD A,$02       ;value +2
AE3B: LD DE,($C3AA)  ;load coords
      ADD A,D        ;add either +2 or -2 to coord
      LD D,A
      LD BC,$1818    ;player's size
      CALL $C858     ;scan rectangle
      JR NZ,$AE58    ;don't do anything if some blocks were found
      LD A,($C4AF)
      BIT 7,A        ;check direction bit
      JR Z,$AE55
      CALL $C924     ;move screen to the right
      JR $AE58
AE55: CALL $C950     ;move screen to the left
AE58: LD HL,$C4C0    ;??
      DEC (HL)       ;decrement it
      JR NZ,$AE71
      LD (HL),$04    ;put this value, if it became 0
      LD HL,$C3AF    ;??
      LD A,(HL)
      AND $07        ;mask
      JR Z,$AE6E
      DEC A          ;decrement
      JR NZ,$AE6E
      LD ($C3A9),A   ;if 0, write here
AE6E: OR $C0
      LD (HL),A
AE71: LD HL,$C4C1    ;?? dying frame
      INC (HL)       ;increment
      LD A,$4B
      LD ($C4C4),A   ;??
AE7A: RET

----------------------
;$AE9C: calculate full (multiplied) strength for current weapon - $AEB5
;Result: reg A contains full strength for current weapon
$AE9C LD A,($C3A0)   ;current weapon code
      INC A          ;inc
      LD B,A         ;and copy here
      LD HL,$C3A3
      LD A,(HL)      ;load dagger strength
      ADD A,A        ;*2
      DEC B          ;check if current weapon is dagger
      RET Z          ;return damage in reg A
      LD HL,$C3A2
      LD A,(HL)      ;load arrow strength
      DEC B          ;check if current weapon is arrow
      RET Z          ;return damage in reg A
      LD HL,$C3A4
      LD A,(HL)      ;load axe strength
      LD C,A
      ADD A,A
      ADD A,C        ;*3
$AEB5 RET            ;return damage in reg A


----------------------
$AF90 ????

$AF90 LD A,($C39B)   ;??
      AND A
      RET Z          ;exit if this variable is 0
      LD B,A         ;copy to reg B
      DEC A          ;decrement
      LD ($C39B),A   ;and store back
      CP $30         ;compare with ??
      RET NC         ;return if greater
      XOR B          ;xor against prev value
      AND $04        ;keep this bit
      RET Z          ;exit if not set
      BIT 2,B
      JP NZ, $A69F   ;???
      LD A,$C5       ;??
      LD ($C3AF),A   ;??
      CALL $D903     ;find sprite descriptors for level
      JP $D98F       ;copy colour info
----------------------
      LD A, $45
      CALL $EAEE
      LD B, $03
      LD DE, $C332
      LD HL, $C333
$AFBE LD A, (DE)
      LD C, (HL)
      LD (HL), A
      LD A, C
      LD (DE), A
      INC HL
      DEC DE
      DJNZ $AFBE
      INC DE
      LD HL, $EACF
      CALL $B10E
      JP C, $B0E0
      JP Z, $B0E0
      LD HL, $EAC6
      LD B, $04
$AFD9 LD (HL), $0A
      INC HL
      DJNZ $AFD9
      LD A, ($C399)
      CP $FF
      JR NZ, $AFEF
      LD HL, $EACB
      LD (HL), $0A
      INC HL
      LD (HL), $15
      LD A, $14
$AFEF INC A
      LD ($EACD), A
      LD HL, $C330
      LD DE, $EACF
      LD BC, $0006
      LDIR
      LD DE, $EACF
      CALL $B0E9
      JR C, $B019
      EX DE, HL
      CALL $B0E9
      JR C, $B019
      EX DE, HL
      CALL $B0E9
      JR C, $B019
      EX DE, HL
      CALL $B0E9
      JR C, $B019
      EX DE, HL
$B019 PUSH HL
      PUSH DE
      LD HL, $EA50
      CALL $C1F7
      CALL $C23A
      POP HL
      POP DE
      LD BC, $FFF7
      ADD HL, BC
      LD C, $0A
      LD B, $04
      XOR A
$B02F LD ($C4DA), A
      EXX
      CALL $E6DC
      LD A, $01
      LD BC, $1000
      CALL $A4E1
      EXX
      LD (HL), $29
$B041 PUSH HL
      PUSH BC
      LD A, (HL)
      CP $29
      JR Z, $B04A
      LD C, $29
$B04A LD (HL), C
      XOR A
      LD ($C32F), A
      LD HL, $EA6D
      CALL $C1FC
      LD A, $01
      LD BC, $0800
      CALL $A4E1
      LD A, ($C4DA)
      AND A
      CALL NZ, $A238
      XOR A
      LD ($C4DA), A
      CALL $C573
      LD A, ($C4B3)
      AND $1F
      LD D, A
      POP BC
      POP HL
      JR Z, $B041
      RRA
      JR C, $B081
      RRA
      JR C, $B0B8
      RRA
      JR C, $B0D3
      RRA
      JR C, $B0C7
$B081 LD (HL), C
      INC HL
      LD C, (HL)
      LD A, $FF
      DJNZ $B02F
      BIT 4, D
      JR NZ, $B095
      INC B
      LD (HL), $43
      DEC HL
      LD C, (HL)
      LD A, $FF
      JR $B02F
$B095 LD (HL), $43
      LD HL, $EA6D
      CALL $C1FC
      LD DE, $0001
      LD BC, $0050
$B0A3 LD HL, $0100
      PUSH BC
      PUSH DE
      CALL $E6E5
      POP DE
      POP BC
      LD A, C
      SUB $04
      LD C, A
      INC E
      LD A, E
      CP $14
      JR NZ, $B0A3
$B0B7 RET

----------------------

----------------------
$B118 - check fire button, create a weapon missile if needed - $B1FC

$B118 LD A,($C4B0)   ;??
      CP $04
      JR Z,$B123     ;skip if $04
      DEC A          ;decrement. If was 0, becomes $FF
      CP $0F
      RET C          ;return if less than $0F
$B123 LD A,($C4B3)   ;?? currently pressed keys ??
      BIT 4,A        ;check bit (?? fire button ??)
      JP NZ,$B12F    ;skip if not set
      XOR A
      LD ($C4B5),A   ;put 0 here
$B12F LD A,($C4C6)   ;??
      AND A          ;check if 0
      JR Z,$B13A
      DEC A          ;if not, decrement
      LD ($C4C6),A   ;and write back
      RET            ;and return
$B13A LD A,($C4B3)   ;read again (?? currently pressed keys ??)
      BIT 4,A        ;check bit 4 (?? fire button ??)
      RET Z          ;exit if not set
      LD A,($C4B5)
      AND A
      RET NZ
      LD A,($C4BE)   ;?? (?? currently fired missiles ??)
      CP $03
      RET Z          ;return if $03 (?? max ??)
      LD HL,$C3B5    ;colliding dynamic objects base address
      LD BC,$000C    ;dynamic object structure size
;find first empty entry in dynamic objects list
$B151 LD A,(HL)      ;read value
      AND A
      JR Z,$B158
      ADD HL,BC      ;if not 0, add structure size, thus moving to next struct
      JR $B151       ;and loop
;fill dynamic object entry
$B158 LD A,($C3A0)   ;current weapon
      AND A          ;
      JR Z,$B190     ;handler if 0
      DEC A
      JR Z,$B17F     ;handler if 1
      DEC A
      JR Z,$B16E     ;handler if 2
;handler for weapon 3 (bolt)
      LD A,$0C
      EX AF,AF'      ;put $0C in A'
      LD A,$44       ;put $44 to A
      LD BC,$2446    ;this value to reg BC
      JR $B19F
;handler for weapon 2 (axes)
$B16E LD A,($C3A4)   ;current strength for axes, base value
      SRL A          ;/2
      SUB $0C
      NEG            ;A = $0C - A
      EX AF,AF'      ;to A'
      LD A,$42       ;put $42 to A
      LD BC,$2846    ;this value to reg BC
      JR $B19F
;handler for weapon 1 (arrows)
$B17F LD A,($C3A2)   ;current strength for arrows
      SRL A          ;/2
      SUB $0A
      NEG            ;A = $0A - A
      EX AF,AF'      ;to A'
      LD A,$41       ;put $41 to reg A
      LD BC,$2444    ;this value to BC
      JR $B19F
;handler for weapon 0 (daggers)
$B190 LD A,($C3A3)   ;current strength for daggers
      SRL A          ;/2
      SUB $0B
      NEG            ;A = $0B - A
      EX AF,AF'      ;to A'
      LD A,$40       ;this value to A
      LD BC,$2045    ;this value to BC
;common handler, has reg A, reg A' and reg BC set up
$B19F LD (HL),A      ;store in structure's 0th byte
      INC HL
      LD A,$0B       ;sound of weapon
      LD ($A25C),A   ;to play
      LD DE,($C3AA)  ;?? current absolute coordinate of a player in pixels ??
      LD A,($C4AF)   ;load player's state
      AND $40        ;mask, keep the sitting status
      LD A,E         ;take this value if bits are 0
      JR Z,$B1B4     ;jump if bits are 0
      ADD A,$08      ;add this value to coord if player is sitting
$B1B4 ADD A,$08      ;add this value
      LD (HL),A      ;write to 01th byte of structure (coord)
      INC HL         ;move to 02th byte of structure
      LD A,D         ;get
      ADD A,$04      ;add
      LD (HL),A      ;write to 02th byte of structure
      INC HL         ;move to 03th byte of structure
      LD A,($C4AF)   ;player's sprite number
      AND $80        ;mask, get direction left/right
      RLCA           ;move direction into bit 0
      OR B           ;combine with reg B
      LD (HL),A      ;write to 03th byte
      INC HL         ;move to 04th byte
      LD (HL),$80    ;just write
      INC HL         ;move to 05th byte
      INC HL         ;move to 06th byte
      LD A,($C4B8)   ;??
      AND A
      JR Z,$B1D2
      LD C,$42       ;this value if $C4B8 is 0
$B1D2 LD (HL),C      ;into 06th byte
      INC HL         ;move to 07th byte
      LD (HL),$14    ;this value to 07th byte (?? size ??)
      INC HL
      LD (HL),$08    ;this value to 08th byte (?? size ??)
      INC HL
      INC HL
      LD (HL),$FE    ;this value to $0Ath byte
      INC HL
      LD (HL),$00    ;this value to $0Bth byte
      LD HL,$C4BA    ;??counter of dynamic objects?? makes sense
      INC (HL)       ;increment it
      LD A,($C3A0)   ;read current weapon
      CP $03
      JR NZ,$B1F1
      LD HL,$C4BB    ;if weapon is $03
      INC (HL)       ;increment this counter also
      JR $B1F5
$B1F1 LD HL,$C4BE    ;for normal weapons this counter
      INC (HL)       ;increment (?? currently fired missiles ??)
$B1F5 EX AF,AF'
      LD ($C4C6),A   ;put former A' here
      LD ($C4B5),A   ;and here
$B1FC RET

----------------------
;$B1FD ?? make random value ?? - $B211

$B1FD PUSH HL
      LD HL,($C4D6)  ;??? example value $0357
      INC HL
      LD A,H
      AND $07
      ADD A,$03
      LD H,A
      LD B,(HL)      ;example value: from ($0658) read $74
      LD ($C4D6),HL  ;write back
      LD A,($C4B3)   ;currently pressed keys
      ADD A,B
      POP HL
$B211 RET

----------------------
;$B212 ?? Generate random monster ??

B212: LD A,($C4BC)   ;???
      AND A
      JR Z,$B21D
      DEC A
      LD ($C4BC),A   ;??
$B21C RET
$B21D LD A,($C4BB)   ;??
      CP $03
      RET NC
      LD A,($C4B0)   ;??
      CP $06
      RET Z
      LD IX,($C4D0)  ;base address of something
      LD A,(IX+$00)  ;load first byte, example value: $03
      AND A
      RET Z          ;exit if 0
;this code is executed when new monster has to be generated
      LD L,(IX+$02)
      LD H,(IX+$03)  ;load in HL full horizontal coordinate
      LD DE,($C4E0)  ;horizontal coord of screen in pixels
      INC DE
      AND A
      SBC HL,DE      ;subtract
      JP NC,$B2E0
      LD L,(IX+$06)
      LD H,(IX+$07)  ;load in HL another full horizontal coordinate in pixels
      SBC HL,DE
      JP C,$B2E0
      LD L,(IX+$04)
      LD H,(IX+$05)  ;load in HL full vertical coordinate in pixels
      LD DE,($C4E2)  ;vertical coord of screen in pixels
      INC D
      AND A
      SBC HL,DE      ;subtract
      JP NC,$B2E0
      LD L,(IX+$08)
      LD H,(IX+$09)  ;load in HL another full vertical coordinate in pixels
      SBC HL,DE      ;subtract
      JP C,$B2E0
$B26A CALL $B1FD     ;?? make random value in reg A ??
      AND $1F        ;mask
      ADD A,$30
      LD H,A         ;store here
      LD A,($C399)   ;??
      ADD A,A
      ADD A,A
      ADD A,A       ;*8
      SUB H
      NEG
      LD ($C4BC),A  ;??
      LD HL,($C4E8) ;coordinates of upper-left visible labyrinth block
      DEC H
$B282 CALL $B449
      JR C,$B2A9
B287: LD HL,($C4E8)
B28A: LD A,($C4E5)
B28D: LD B,$05
B28F: AND A
B290: JR NZ,$B293
B292: DEC B
B293: LD A,H
B294: ADD A,B
B295: LD H,A
B296: CALL $B449
B299: RET NC
...

B2A9: PUSH HL
B2AA: LD HL, ($C4E8)
B2AD: LD A, ($C4E5)
B2B0: LD B, $05
B2B2: AND A
B2B3: JR NZ, $B2B6
B2B5: DEC B
B2B6: LD A, H
B2B7: ADD A, B
B2B8: LD H, A
B2B9: CALL $B449
B2BC: EX DE, HL
B2BD: POP HL
B2BE: LD C, $00
B2C0: JR C, $B2CF
B2C2: LD A, ($C4E6)
B2C5: AND A
B2C6: JP Z, $B2FE
B2C9: BIT 7, A
B2CB: RET NZ
B2CC: JP $B2FE
B2CF: LD A, ($C4E6)
B2D2: AND A
B2D3: JR Z, $B2E8
B2D5: LD C, $00
B2D7: BIT 7, A
B2D9: JR Z, $B2FE
B2DB: LD C, $01
B2DD: EX DE, HL
B2DE: JR $B2FE

----------------------

$B334 - ?



$B334 LD C,A         ;transfer value through reg C
      EX AF,AF'      ;and save in A'
      LD A,C         ;now from reg C
      AND $07        ;mask
      CP $07         ;check if all low bits are 1
      JR Z,$B39B     ;jump if no
      LD A,($C4BA)   ;counter of dynamic objects?
      AND A
      JP Z,$B39B     ;jump if 0
      LD ($C4B7),A   ;temp copy???
      PUSH BC
      PUSH DE
      LD IX,$C3B5    ;colliding dynamic objects base address
$B34D LD A,(IX+$00)  ;get fisrt byte
      AND A
      JR NZ,$B35B    ;
$B353 LD BC,$000C    ;if 0, then add structure size, move to next struct
      ADD IX,BC
      JP $B34D
$B35B LD B,A         ;save value
      AND $18        ;mask
      JR NZ,$B391    ;jump if has some bits
      LD A,B         ;restore
      LD BC,$1008    ;??
      AND $07        ;mask
      CP $05         ;check
      JR C,$B37F
      LD L,(IX+$01)
      LD H,(IX+$02)
      POP DE
      PUSH DE
      EXX
      LD B,(IX+$07)
      LD C,(IX+$08)
      EXX
      CALL $C03D     ;check if intersects
      JR C,$B38D
$B37F LD A,($C4B7)
      DEC A
      LD ($C4B7),A
      JR NZ,$B353
      POP DE
      POP BC
      JP $B39B
$B38D POP DE
      POP BC
      AND A
$B390 RET
$B391 CP $08
$B393 JR Z, $B37F
$B395 LD BC, $1818
$B398 JP $B36A


B39B: EXX
B39C: LD HL,$C3B5    ;colliding dynamic objects base address
B39F: LD BC, $000C
B3A2: LD A, (HL)
B3A3: AND A
B3A4: JR Z, $B3A9
B3A6: ADD HL, BC
B3A7: JR $B3A2
B3A9: PUSH HL
B3AA: POP IX
B3AC: EXX
B3AD: LD (IX+$01), E
B3B0: LD (IX+$02), D
B3B3: LD (IX+$03), B
B3B6: EX AF, AF'
B3B7: LD B, A
B3B8: AND $07
B3BA: LD C, A
B3BB: LD A, B
B3BC: RRCA
B3BD: RRCA
B3BE: RRCA
B3BF: AND $1F
B3C1: INC A
B3C2: LD (IX+$05), A
B3C5: LD B, $00
B3C7: LD HL, $B421
B3CA: ADD HL, BC
B3CB: LD A, (HL)
B3CC: LD B, A
B3CD: AND $1F
B3CF: OR $40
B3D1: LD (IX+$00), A
B3D4: LD A, ($C4B8)
B3D7: AND A
B3D8: LD A, $41
B3DA: JR NZ, $B3E7
B3DC: LD A, B
B3DD: AND $1F
B3DF: LD L, A
B3E0: LD H, $00
B3E2: LD DE, $B429
B3E5: ADD HL, DE
B3E6: LD A, (HL)
B3E7: LD (IX+$06), A
B3EA: LD A, B
B3EB: LD DE, $1008
B3EE: SRL A
B3F0: SRL A
B3F2: SRL A
B3F4: AND $03
B3F6: JR Z, $B407
B3F8: LD DE, $1810
B3FB: DEC A
B3FC: JR Z, $B407
B3FE: LD DE, $1818
B401: DEC A
B402: JR Z, $B407
B404: LD DE, $1830
B407: LD (IX+$07), D
B40A: LD (IX+$08), E
B40D: XOR A
B40E: LD (IX+$04), A
B411: LD (IX+$09), A
B414: LD (IX+$0B), A
B417: LD (IX+$0A), $FE
B41B: LD HL, $C4BA
B41E: INC (HL)
B41F: SCF
B420: RET

----------------------
;$B449 ??

;Params: IX (example: $DE52), regs H,L - coordinates in blocks
;Returns: CF=1 ??when??

$B449 LD A,(IX+$00)  ;example value: $03
      CP $05
      JR Z,$B496
      DEC A
      JR Z,$B4A3
      DEC A
      JR Z,$B4A3
      LD A,($C4E4)   ;shift of block in pixels
      LD E,$08       ;normal value for additional coord
      AND A
      JR NZ,$B45F
      DEC E          ;if block is not shifted, decrement additional coord
$B45F LD D,$00
$B461 CALL $C8CD     ;calculate block's address
      LD B,$07       ;loop counter
      LD DE,$FFE2    ;it's a -1E
$B469 LD A,(HL)      ;read block value
      LD C,A         ;save in reg C
      ADD HL,DE      ;add (subtract, in fact), get to one block above
      AND $0F        ;mask
      JR NZ,$B473    ;exit if found
      DJNZ $B469     ;or loop, if not found
$B472 RET            ;return from proc
;found block
$B473 LD A,C         ;value before mask
      AND $C0        ;new mask
      JR Z,$B47B
      DJNZ $B473     ;?? why
      RET
;another loop
$B47B LD A,(HL)      ;block value
      INC HL         ;move to the block to the right
      OR (HL)        ;combine
      DEC HL         ;move back
      ADD HL,DE      ;move one block up
      AND $0F
      JR Z,$B487     ;go if found
      DJNZ $B47B
      RET
;another loop, very similar
$B487 LD A,(HL)
      INC HL
      OR (HL)
      DEC HL
      AND $0F
      JR Z,$B494
      ADD HL,DE
      DJNZ $B47B
      AND A
      RET
$B494 SCF
$B495 RET

B496: LD DE, $0001
B499: CALL $C8CD
B49C: LD B, $06
B49E: LD DE, $001E
B4A1: JR $B47B
B4A3: LD DE, $0001
B4A6: CALL $C8CD
B4A9: LD B, $06
B4AB: LD DE, $001E
B4AE: LD A, (HL)
B4AF: INC HL
B4B0: OR (HL)
B4B1: DEC HL
B4B2: AND $0F
B4B4: JR Z, $B494
B4B6: ADD HL, DE
B4B7: DJNZ $B4AE
B4B9: AND A
B4BA: RE

----------------------
;$B4BB - check if location trigger is hit, activate monster ??

$B4BB LD A,($C4BB)   ?? ;read variable
      CP $04         ;check
      RET NC         ;exit if greater or equal
      LD IX,($C4CE)  ;?? base address, start of structures 06 bytes each ?? example value: $E17A for level 1
;loop
$B4C5 LD A,(IX+$00)
      AND A
      RET Z          ;exit if 0
$B4CA BIT 7,A        ;check bit
      JR Z,$B4D5
$B4CE LD BC,$0006    ;size of structure
      ADD IX,BC      ;move to next structure
      JR $B4C5       ;loop
$B4D5 LD BC,$1008    ;special value
      AND $18        ;mask
      JR Z,$B4DF     ;if all remaining bits are 0, use special value
      LD BC, $1818   ;default value
$B4DF CALL $C000     ; ?? check if object goes outside of screen ??
      JR NC,$B4CE    ;to next struct
;this code is executed when a trigger location is hit: dragon or ball appears
      EX DE,HL
      PUSH BC        ;save BC
      LD BC,$0101    ;argument
      LD HL,$241C    ;argument
      EXX
      LD BC,$B068    ;argument
      EXX
      CALL $C03D     ;check if intersects with ???
      POP BC         ;restore
      JR C,$B4CE     ;to next struct
      LD A,(IX+$05)
      BIT 7,D
      JR Z,$B500
      OR $01
$B500 BIT 7,E
      JR Z,$B506
      OR $02
$B506 LD B,A
      LD A,(IX+$00)
      AND $07
      LD C,A
      LD A,(IX+$00)
      AND $F8
      RLCA
      OR C
      PUSH IX
      CALL $B334
      POP IX
      JP NC,$B4CE
      SET 7,(IX+$00)
      LD HL,$C4BB
      INC (HL)
$B526 RET

----------------------
;$B527: Check if player hits the monster - $B5AC

$B527 LD A,($C4C2)   ;??
      AND A          ;check if 0
      RET NZ         ;return if not
      LD A,($C4B0)   ;game state
      CP $04
      JR Z,$B537
      DEC A          ;if was 0, becomes $FF
      CP $0F
      RET C
$B537 LD A,($C4BA)   ;number of colliding dynamic objects
      AND A
      RET Z          ;return if there are no
      LD ($C4DA),A   ;init loop counter
$B53F LD IX,$C3B5    ;colliding dynamic objects base address
;loop
$B543 LD A,(IX+$00)  ;read status byte
      AND A
      JR NZ,$B551
      LD BC,$000C    ;struct size
      ADD IX,BC      ;add, so move to next struct in list
$B54E JP $B543       ;loop
$B551 BIT 7,A        ;?? check this bit
$B553 JP NZ,$B5A6    ;ignore this object for player
      LD B,A         ;save status byte
      AND $18        ;mask, keep bits 3 and 4
      JR NZ,$B5A2    ;go if there is something in these bits
$B55B LD A,B         ;restore status byte
      AND $07        ;mask
      CP $04         ;compare with
      JR C,$B5A6     ;ignore if less
      JR NZ,$B56B
      LD A,(IX+$06)  ;??
      CP $46
      JR Z,$B5A6     ;ignore if equals
$B56B LD BC,$0214    ;if standing, B - vertical offset, C - vertical size
      LD A,($C4AF)   ;player's state
      BIT 6,A        ;check if he is sitting
      JR Z,$B578
      LD BC,$0A0C    ;if sitting, B - vertical offset, C - vertical size
$B578 LD HL,($C3AA)  ;read player's coordinates on a screen
      LD A,H         ;horizontal coord
      ADD A,$0C      ;add
      LD H,A         ;write back
      LD A,L         ;vertical coord
      ADD A,B        ;add offset
      LD L,A         ;write back
      LD A,C
      EXX
      LD C,A         ;vertical size
      LD B,$06       ;horizontal size
      EXX
      LD E,(IX+$01)  ;colliding object's vertical coord
      LD D,(IX+$02)  ;colliding object's horizontal coord
      LD B,(IX+$07)  ;colliding object's width
      LD C,(IX+$08)  ;colliding object's height
      CALL $C03D     ;check if intersect
$B597 JR NC,$B5A6
;this code is executed if monster collides with the player
      LD A,$01
      LD ($C4B0),A   ;'death' status
      LD ($A25C),A   ;sound of death
$B5A1 RET
$B5A2 CP $08         ;?? check 'monster is dying' ??
      JR NZ,$B56B
;objects don't intersect
$B5A6 LD HL,$C4DA
      DEC (HL)       ;decrement loop counter
      JR NZ,$B549    ;back to loop, if there is something remains
$B5AC RET            ;exit otherwise


----------------------

$B5AD - Collision detection ?????

$B5AD LD A,($C4BA)   ;read the counter of dynamic objects
      AND A
      RET Z          ;exit if 0
      DEC A          ;decrement it
      RET Z          ;exit if 0
      LD ($C4DA),A   ;store here
      LD ($C4DC),A   ;and here
      LD IX,$C3B5    ;colliding dynamic objects base address
$B5BE LD A,(IX+$00)  ;load first byte
      AND A          ;check if 0
      JR NZ,$B5CC    ;handle if not 0
$B5C4 LD BC,$000C    ;structure size
      ADD IX,BC      ;if 0, then move to next structure
$B5C9 JP $B5BE       ;loop


$B5CC BIT 7,A        ;check if already handled
$B5CE JP NZ,$B68E    ;if yes, decrement counters and back into loop
;check if dynamic object collides with subsequent objects
$B5D1 PUSH IX
      POP IY         ;copy IX to IY
;depending on first byte, calculate value for ($C4DE)
      LD A,(IX+$00)  ;load first byte
      LD B,$00
      AND $1F        ;mask it
      CP $04
      JR Z,$B5EC     ;jump if reg A=$04, will have reg B=$00
      LD B,$04
      JR C,$B5EC     ;jump if reg A<$04, will have reg B=$04
      LD B,$08
      CP $15
      JR NZ,$B5EC    ;jump if reg A>$04, will have reg B=$08
      LD B,$0C       ;fall here if reg A=$015, makes reg B=$0C
$B5EC LD A,B
      LD ($C4DE),A   ;store here
;secondary loop: scan subsequent structures, find first one with non-0 first byte, calc ??? and add
$B5F0 LD BC,$000C    ;structure size
      ADD IY,BC      ;now IY points to next structure
      LD A,(IY+$00)  ;load first byte
      AND A          ;check if 0
      JR Z,$B5F0     ;skip if 0, loop
      BIT 7,A        ;check bit 7
      JP NZ,$B687    ;jump far below
      LD A,(IY+$00)  ;read again
      AND $1F        ;mask, then calc value in reg C similar to reg B above
      LD C,$00
      CP $04
      JR Z,$B614
      INC C
      JR C,$B614
      INC C
      CP $15
      JR NZ, $B614
      INC C
$B614 LD A,($C4DE)   ;restore calculated value
      LD B,A         ;copy in reg B
      ADD A,C        ;add another calculated value from reg C
      LD L,A
      LD H,$00       ;move into HL
      LD DE,$B76A    ;??base address?
      ADD HL,DE      ;add offset
      LD A,(HL)      ;read collision style
      AND A          ;check if 0
      JR Z,$B687     ;if collision style=0, objects don't collide
      DEC A
      JP Z,$B69E     ;if collision style=1
      DEC A
      JR Z,$B648     ;if collision style=2

;collison style = 3
$B62B PUSH BC        ;save BC
$B62C CALL $B74D     ;check collision
      POP BC         ;restore BC
      JP NC, $B687   ;jump if not collide
      LD A,B
      CP $0C         ;check this special value
$B636 JR Z,$B63E
$B638 CALL $B77A     ;modify first object
$B63B JP $B68E       ;get into first loop
$B63E CALL $B78D     ;modify second object
      LD HL,$C4DA
      DEC (HL)       ;decrement counter
      JP $B68E       ;back to the loop

;collision style = 2, monster vs monster
$B648 CALL $B74D     ;check collision
      JR NC,$B687    ;jump out if not collide
      LD A,(IX+$09)  ;falling speed of first monster
      OR (IY+$09)    ;falling speed of first monster
      JR NZ,$B66E    ;if at least one is not 0, one monster crushes another
$B655 LD A,(IX+$03)  ;? something from first object
      XOR $03        ;flip two low bits ? direction bits ?
      LD (IX+$03),A  ;store back
      LD A,(IY+$03)  ;something from second object
      XOR $03        ;flip two low bits ? direction bits ?
      LD (IY+$03),A  ;store back
      INC (IX+$0B)   ;??
      INC (IY+$0B)   ;??
$B66B JP $B68E       ;back to outer loop
$B66E LD A,(IX+$01)  ;coordinate of first monster
      CP (IY+$01)    ;coordinate of second monster
      JP C,$B67D     ;jump if less (so, second coord is greater, so second is below first)
      CALL $B77A     ;modify first object
      JP $B68E       ;back to outer loop
$B67D CALL $B78D     ;modify second object
      LD HL,$C4DA
      DEC (HL)       ;decrement counter
$B684 JP $B68E       ;back to outer loop

;objects don't collide
$B687 LD HL,$C4DC    ;counter
      DEC (HL)       ;decrement it
      JP NZ,$B5F0    ;keep scanning in secondary loop

;finished checking for collisions for current object
$B68E LD A,($C4DA)   ;read counter (it may be decremented before)
      AND A
      RET Z          ;return if 0
      DEC A          ;decrement
      RET Z          ;return if 0
      LD ($C4DA),A   ;save back
      LD ($C4DC),A   ;and also here
$B69B JP $B5C4       ;back to the loop

;collision style = 1, weapon vs monster
$B69E PUSH BC        ;store
      CALL $B74D     ;check collision       ``
      POP BC         ;restore
      JR NC,$B687    ;objects don't collide
      LD A,C         ;load type of second object
      AND A          ;check
      JR Z,$B713     ;go if 0
      CP $01
      JR Z,$B705     ;go if weapon (type = 1)
      LD A,$08
      LD ($A25C),A   ;??
      LD A,($C3A5)   ;??
      SUB (IY+$05)
      CPL
      INC A
      LD (IY+$05),A
B6BD: JR NC,$B6C9
B6BF: LD A,(IY+$06)
B6C2: AND $07
B6C4: LD (IY+$06),A
B6C7: JR $B6D0
B6C9: CALL $B78D     ;modify second object
B6CC: LD HL,$C4DA
B6CF: DEC (HL)       ;decrement counter
$B6D0 LD A,B         ;check type of first object
B6D1: AND A
B6D2: JR Z,$B729     ;go if 0
B6D4: CP $04
B6D6: JR Z,$B6FB
;monster was killed
B6D8: LD A,$08       ;sound of monster death?
B6DA: LD ($A25C),A   ;to play
B6DD: LD A,($C3A5)   ;??
B6E0: SUB (IX+$05)   ;??
B6E3: CPL
B6E4: INC A
B6E5: LD (IX+$05),A
B6E8: JR C,$B6F0
B6EA: CALL $B77A     ;modify first object
B6ED: JP $B68E       ;back to outer loop
B6F0: LD A,(IX+$06)
B6F3: AND $07
B6F5: LD (IX+$06),A
B6F8: JP $B68E       ;back to outer loop
B6FB: LD (IX),$00    ;set first byte of first object
B6FF: CALL $B744     ;decrement two counters
B702: JP $B68E       ;back to outer loop
;??
$B705 LD (IY),$00    ;mark second object as destroyed
B709: CALL $B744     ;decrement two counters
B70C: LD HL,$C4DA
B70F: DEC (HL)       ;decrement this counter
B710: JP $B6D0
B713: LD A, (IY+$06)
B716: CP $46
B718: JP NZ, $B687
B71B: LD (IY+$00), $00
B71F: CALL $B73B
B722: LD HL, $C4DA
B725: DEC (HL)
B726: JP $B6D0
B729: LD A, (IX+$06)
B72C: CP $46
B72E: JP NZ, $B68E
B731: LD (IX+$00), $00
B735: CALL $B73B
B738: JP $B68E

----------------------
$B73B - decrement two counters

$B73B LD HL, $C4BA
      DEC (HL)
      LD HL, $C4BB
      DEC (HL)
$B743 RET

----------------------
$B744 - decrement two counters

$B744 LD HL,$C4BA
      DEC (HL)
      LD HL,$C4BE
      DEC (HL)
$B74C RET

----------------------
$B74D - check if two dynamic objects collide - $B767 (+2)

params:
IX,IY - pointers to structures to check
returns CF=1 if structures collide

$B74D LD E,(IX+$01)  ;coord of first object
      LD D,(IX+$02)  ;coord of first object
      LD C,(IX+$08)  ;size of first object
      LD B,(IX+$07)  ;size of first object
      LD L,(IY+$01)  ;coord of second object
      LD H,(IY+$02)  ;coord of second object
      EXX
      LD C,(IY+$08)  ;size of second object
      LD B,(IY+$07)  ;size of second object
      EXX
$B767 JP $C03D       ;check if rectangles intersect, will return to caller

----------------------


----------------------
$B77A - modify dynamic object after collision - $B77A

Params: IX points to dynamic object structure

$B77A LD A,(IX+$00)  ;first byte
      LD (IX+$05),A  ;save here
      AND $18        ;mask, keep bits 3 and 4
      OR $80         ;set bit 7
      LD (IX+$00),A  ;store back
      LD A,$07
      LD ($A25C),A   ;???
$B78C RET

----------------------
$B78D - modify dynamic object after collision - $B79F

The same as $B77A, but object is addressed by IY instead of IX
Params: IY points to dynamic object structure

$B78D LD A, (IY+$00)
      LD (IY+$05),A
      AND $18
      OR $80
      LD (IY+$00),A
      LD A, $07
      LD ($A25C),A
$B79F RET

----------------------
$B7A0 - Monster and missile movement, collision to walls, falling down

currently active monsters and missiles list is starting at $C3B5

$B7A0 LD A,($C4B0)   ;???
      CP $06
      RET Z
      LD A,($C4BA)   ;number of monsters+missiles???
      AND A
      RET Z
      LD ($C4DC),A   ;store copy here, counter of handled objects
      LD IX,$C3B5    ;monster/missile list base address
;outer loop, handle all objects
;scan until first used will be found
$B7B2 LD A,(IX+$00)
      AND A          ;check status if 0
      JR NZ,$B7BF    ;found
$B7B8 LD BC, $000C
      ADD IX, BC
$B7BD JR $B7B2       ;loop
$B7BF BIT 7,A        ;check bit 7
      JR NZ,$B7E1
      LD A,(IX+$03)  ;?? example value: 09, defines handler for this type of monster
      SRL A          ;shift to the left
      AND $FE        ;mask, clean low bit
      LD L,A
      LD H, 00       ;make it an offset
      LD BC,$DB92    ;base address of handler table
      ADD HL,BC      ;add
      LD E,(HL)      ;load value from table, example: $EA
      INC HL         ;to next
      LD D,(HL)      ;load value from table, example: $B8
      EX DE,HL       ;move into HL
      CP $10         ;??
      JR NC,$B803
      JP (HL)        ;jump to handler. Examples: $B8EA, $B8BC, $B8BF
;will return from handler here
$B7DA LD HL,$C4DC    ;counter of handled objects
      DEC (HL)       ;decrement
$B7DE JR NZ,$B7B8    ;back to object scanning loop
$B7E0 RET            ;return

;invoked when one monster falls on another
$B7E1 LD B,A
      INC A
      AND $07
      JR NZ,$B7F6
      LD E,(IX+$05)
      CALL $C056
      LD A,(IX+$05)
$B7F0 CALL $BA94
$B7F3 JP $B7DA
$B7F6 OR $80
      LD C, A
      LD A, B
      AND $18
      OR C
B7FD: LD (IX+$00), A
B800: JP $B8BF

;invoked for arrow
$B803 LD A,(IX+$0B)  ;?? read
      AND A
      JR Z,$B856
      DEC A          ;decrement
      LD (IX+$0B),A  ;write back
      LD C,(IX+$0A)  ;??
      LD B,$00       ;offset in BC
      ADD HL,BC      ;add to base
      LD A,(HL)      ;example value: $04
      CP $FD
      JR NZ,$B81A
      LD A,$11
$B81A LD C,A
      LD A,(IX+$03)  ;example value: $25
      RLCA
      RLCA
      RLCA
      XOR C
      LD B,A
      LD A,C
      AND $07
      ADD A,A
      BIT 3,B
B829: JR Z, $B82D
B82B: NEG
B82D: LD B, A
B82E: LD A, (IX+$03)
B831: RRCA
B832: RRCA
B833: XOR C
B834: LD D, A
B835: LD A, C
B836: AND $70
B838: SRL A
B83A: SRL A
B83C: SRL A
B83E: BIT 7, D
B840: JR Z, $B844
B842: NEG
B844: LD C, A
B845: CALL $B927
B848: LD A, D
B849: XOR (IX+$03)
B84C: LD D, A
B84D: LD A, E
B84E: ADD A, A
B84F: XOR D
B850: LD (IX+$03), A
B853: JP $B7DA


$B856 LD A,(IX+$0A)  ;??
      INC A
      INC A
      LD (IX+$0A),A  ;store back
      EX DE,HL
      LD L,A
      LD H,$00
      ADD HL,DE
      EX DE,HL
      LD A,(DE)
      CP $FB
B867: JR C,$B891
B869: INC A
B86A: JR NZ, $B872
B86C: LD (IX+$0A), $FE
B870: JR $B856
...

$B891 INC DE
      LD A,(DE)
      LD (IX+$0B), A
$B896 JP $B803

;one of the handlers, for monk
$B8EA LD C,(IX+$09)  ;current falling frame for a monster
      LD B,$00
      LD HL,$C5D8    ;falling speed table base
      ADD HL,BC      ;add offset
      LD A,(HL)      ;load falling speed
      INC C          ;to next frame
      CP $FF         ;check for special value
      JR NZ,$B8FC
      DEC HL         ;move to prev value in table
      LD A,(HL)      ;load speed
      DEC C          ;decrement frame (since it was incremented, it remains the same as it was)
$B8FC LD (IX+$09),C  ;store frame
      LD C,A         ;speed here
      LD D,(IX+$03)  ;?? it defines offset of handler in handler table
      LD A,$01
      BIT 0,D        ;check this bit, depending on it value of reg A will be either +1 or -1
      JR Z,$B90B
      NEG            ;if bit is set then negate
$B90B LD B,A         ;copy here
$B90C CALL $B927
      LD A,D         ;not 0 if there were horizontal collision
      AND A
      JR Z,$B91B     ;go if there were no horizontal collision
      LD A,(IX+$03)  ;read value
      XOR $01        ;flip direction bit
      LD (IX+$03),A  ;write back
$B91B LD A,E         ;not 0 if there were vertical collision
      AND A
      JP Z,$B7DA     ;no collisions, return from handler to loop
      LD (IX+$09),$00;??
$B924 JP $B7DA       ;return from handler to loop

;when coming here reg B has either +1 or -1, horizontal monster movement value, reg C has vertical falling movement
$B927 LD A,($C4E7)   ;vertical screen movement up since last frame in pixels
      ADD A,(IX+$01) ;add monster vertical coord, since as screen moves up, content relatively moves down
      LD (IX+$01),A  ;store back
      BIT 7,(IX+$04) ;??
      JR NZ, $B951
      LD A,($C4E6)   ;horizontal screen movement left since last frame in pixels
      LD D,A         ;store here
      BIT 6,(IX+$04) ;??
      JR Z, $B94A
      ADD A, B
      JR NZ,$B94A
      DEC B
      BIT 7,D
      JR NZ,$B94A
      INC B
      INC B
$B94A LD A,(IX+$02)  ;monster horizontal coord
      ADD A,D        ;add screen movement
      LD (IX+$02),A  ;store back
      LD A,(IX+$02)  ;horizontal coord
      ADD A,B        ;add horizontal monster movement value, now reg A has new horizontal coord
      EXX            ;save regs B and C
      CP $E0         ;right border of a screen?
$B958 JP NC, $BA8A
      LD D,A         ;horizontal coord
      LD E,(IX+$01)  ;vertical coord
      LD B,(IX+$07)  ;width
      LD C,(IX+$08)  ;height
      PUSH BC
      PUSH DE
      CALL $C858     ;scan the rectangle
      POP DE
      JR NZ,$B973    ;monster hits the wall while moving left or right
      POP BC
      LD A,$00
$B970 JP $BA34

;monster hits the wall while moving left or right
$B973 LD A,(IX+$00)  ;load value
      AND $18        ;mask
B978: JP NZ,$BA2E
B97B: LD A,(IX+$00)
B97E: AND $07
B980: CP $05
B982: JP NC, $BA2E
B985: LD D, B
B986: DEC HL
B987: BIT 4, (HL)
B989: JR NZ,$B9A5
B98B: DJNZ $B986
B98D: LD A, L
B98E: ADD A, D
B98F: SUB $1E
B991: LD L, A
B992: SBC A, A
B993: ADD A, H
B994: LD H, A
B995: LD B, D
B996: DEC C
B997: JR NZ,$B986
B999: CALL $B77A
B99C: LD A, $0A
B99E: LD ($A25C), A
B9A1: POP BC
B9A2: LD A, $FF
B9A4: RET

...
$BA2E POP BC
      LD D,(IX+$02)
      LD A,$0

;no collision with wall in horizontal direction. reg A has 0
$BA34 LD (IX+$02),D  ;horizontal movement was ok, store updated horizontal coordinate
      EXX            ;restore
      LD D,A         ;save reg A here, 0 if there were no collision
      LD A,C         ;vertical speed
      EXX            ;store
      ADD A,E        ;add to vertical coord
      CP $90
      JR NC,$BA8A    ;?? moved out of screen ??
      LD E,A         ;updated coordinate
      PUSH DE
      CALL $C858     ;scan the rectangle
      POP DE
      LD A,$00
      JR Z,$BA84     ;no collision with level block down, go update the coordinate
;monster on a ground
$BA4A LD A,(IX+$00)  ;
      AND $18        ;mask, keep bits 3 and 4
      JR NZ,$BA5E
      LD A,(IX+$00)
      AND $07
      CP $05
      JR NC,$BA5E
      PUSH BC
$BA5B JP $B985
;loop
$BA5E DEC HL         ;previous level block address??
      LD A,(HL)      ;load
      AND $C0        ;mask
      JR NZ,$BA68
      DJNZ $BA5E
$BA66 JR $BA7F
$BA68 LD A, (IX+$00)
      AND $18
      JR NZ, $BA79
      LD A, (IX+$03)
      XOR $02
      LD (IX+$03), A
      JR $BA7F
$BA79 CALL $B77A
      LD A, $FF
$BA7E RET

$BA7F LD E,(IX+$01)  ;load vertical coord
      LD A,$01       ;flag, there was a collision
$BA84 LD (IX+$01),E  ;store back vertical coord
      EXX
      LD E, A        ;0 if there were no collision
$BA89 RET            ;return

;moves out the border of a screen
$BA8A LD A,(IX+$00)  ;read status
      BIT 7,A        ;check this bit
      JR Z,$BA94
      LD A,(IX+$05)  ;if set, read status from this place
$BA94 LD B,A         ;store status
      LD (IX+$00),$00;release the object
      AND $18        ;mask
      JR NZ,$BAA8
      LD A,B
      AND $07
      CP $03
$BAA2 JP NC,$B73B
$BAA5 JP $B744
$BAA8 CP $08
      JP NZ,$B73B    ;decrement counters and return
$BAAD LD HL,$C4BA
      DEC (HL)
$BAB1 RET

----------------------
$BAB2: Colliding dynamic objects list maintenance - $BAF5


$BAB2 LD IX,$C3B5    ;colliding dynamic objects base address
      LD A,($C4BA)   ;counter of colliding dynamic objects
      AND A
      RET Z          ;exit, if 0

      LD ($C4DA),A   ;copy counter here
;loop until ($C4DA) will be 0
$BABE LD A,(IX)      ;get the status byte
      AND A          ;check if not 0
      JR NZ,$BACB    ;found, handle this case, otherwise skip
$BAC4 LD BC,$000C    ;struct size
      ADD IX,BC      ;add, move to next struct in list
      JR $BABE       ;loop

$BACB BIT 7,A
      JR NZ $BAEF    ;jump if high bit is set
      LD B,A         ;save status
      AND $18        ;mask
      CP 8
      JR Z,$BAE7     ;jump if masked = 8
      AND A
      JR NZ,$BAEF    ;jump if not 0
      LD A,B         ;restore
      AND 7          ;mask
      CP 4
      JR NC,$BAEF    ;jump if > 4
      LD A,(IX+3)    ;?
      CP 1
      JR NZ,$BAEF    ;jump if not 1
$BAE7 LD (IX),0      ;clear status byte, mark entry as unused
      LD HL,$C4BA
      DEC (HL)       ;decrement counter of colliding dynamic objects
$BAEF LD HL,$C4DA
      DEC (HL)       ;decrement loop counter
      JR NZ,$BAC4    ;back to loop
$BAF5 RET


----------------------
;$BAF6: check if statically placed collectable objects are visible, and create a visible object entry for it

$BAF6 LD A,($C398)   ;current level
      CP $08
BAFB: JR NZ,$BB08
      LD A,($C4B0)   ;??
      CP $10
      RET NZ
      LD A,($C4C2)   ;???
      AND A
      RET Z
$BB08 LD A,($B42C)   ;?? example value: $43
      XOR $04        ;flip bit 2
      LD ($B42C),A   ;write back
      LD A,($B435)   ;?? example value: $06
      XOR $41        ;flip bits
      LD ($B435),A   ;write back
      LD A,($C4B0)   ;???
      CP $06
      RET Z
      LD IX,($C4CA)  ;base address for collectablse objects table for current level (for level 1 value is $DF05)
;loop
$BB22 LD A,(IX+$00)
      AND A
      RET Z          ;if first byte is 0, exit
      BIT 7,A        ;check 'collected' bit
      JR Z,$BB32     ;go if object is not collected yet
$BB2B LD BC,$0005    ;list entry size
      ADD IX,BC      ;add, thus moving to next list entry
$BB30 JR $BB22       ;loop

$BB32 LD BC,$1008    ;default size
      AND $0F        ;mask the value
      CP $05         ;check against this
      JR C,$BB3E
      LD BC,$1810    ;alternative size
      CALL $C000     ;check if it is visible
      JR NC,$BB2B    ;if not, return to loop
;we come here if collectable object (skeleton, elemental, diamond, weapon) becomes visible
      EX DE,HL
      LD A,(IX+$00)  ;load object's code
      AND $0F        ;mask
      DEC A
      CP $06
      JP NC,$BCF2
      LD BC,$1008    ;either this size, if code >= 4 (elemental pieces, skeletons)
      CP $04
      JR C,$BB5B
      LD BC,$1810    ;or this size, if code < 4 (weapons, diamonds)
      OR $08         ;and also switch this bit for small objects
$BB5B OR $40         ;always switch this bit
      EX AF,AF'      ;and save in A'

;now find unused entry in visible object list
      LD HL,$C3B5    ;base address of visible objects list
      PUSH BC        ;save width and height
      LD BC,$000C    ;list entry size
$BB65 LD A,(HL)      ;load status byte
      AND A
      JR Z,$BB6C     ;if it is 0, then unused entry is found, ok, will use it for our object
      ADD HL,BC      ;this entry is used, add offset, thus moving to next entry
$BB6A JR $BB65       ;and keep searching in loop

;entry allocated, will populate it
$BB6C POP BC         ;restore width and height
      EX AF, AF'     ;restore status
      LD (HL),A      ;put status in base+0
      INC HL
      LD (HL),E      ;coord in base+1
      INC HL
      LD (HL),D      ;coord in base+2
      INC HL
      LD (HL),$01    ;?? this constant in base+3
      INC HL
      INC HL
      LD (HL),$4B    ;?? this constant in base+5
      INC HL
      EXX            ;save registers
      AND $1F        ;mask status byte
      LD L,A
      LD H,$00       ;make it into an offset
      LD DE,$B429    ;?? some base address ??
      ADD HL,DE      ;add offset
      LD A,($C4B8)   ;??
      AND A
      LD A,(HL)      ;load value from a list
      JR Z,$BB8E     ;it will be used if ($C4B8) is 0
      LD A,$41       ;if it was not 0, this constant will be used
BB8E: EXX            ;restore registers
      LD (HL),A      ;write value into base+6
      INC HL
      LD (HL),B      ;width into base+7
      INC HL
      LD (HL),C      ;height into base+8
      LD HL,$C4BA    ;counter of visible objects
      INC (HL)       ;increment
      LD A,(IX+$00)  ;load object's code again
      AND $0F        ;mask
      CP $07
      JR NC,$BB2B   ;if greater or equals 7, then back to loop
      LD HL,($C3AA) ;coords of player
      LD A,H
      ADD A,$08
      LD H,A
      EXX
      LD BC, $0818  ;player's size
      EXX
      CALL $C03D    ;check if rectangles intersect (player collects the item)
      JP NC,$BB2B   ;if not, go back to loop
;player collects the item
$BBB3 LD A,$09
      LD ($A25C),A  ;??
      LD A,(IX+$00) ;load object's code
      SET 7,(IX+$00);set this bit - object collected
      AND $0F       ;mask, keep low bits
      DEC A         ;dec
      AND $07       ;mask again
      ADD A,A       ;*2
      LD L,A
      LD H,$00      ;make it an offset
      LD BC,$BBD1   ;base address: handlers for collecting objects
      ADD HL,BC     ;add offset
      LD E,(HL)     ;load handler low byte
      INC HL
      LD D,(HL)     ;load handler high byte
      EX DE,HL
$BBD0 JP (HL)       ;execute 'object collected' handler

----------------------
;$BBD1 - $BBDC: primary list of 'object collected' handlers:
;         $BBDD, $BBE4, $BBEB, $BC1F, $BC42, $BC6B
----------------------
;$BBDD, $BBE4, $BBEB : handlers for collecting dagger, axe or arrow

$BBDD LD HL,$C3A3   ;strength of daggers addr
      LD B,$00      ;'dagger' weapon code
      JR $BBF0
$BBE4 LD B,$01      ;'arrow' weapon code
      LD HL,$C3A2   ;strength of arrows addr
      JR $BBF0
$BBEB LD B,$02      ;'axe' weapon code
      LD HL,$C3A4   ;strength of axes addr
$BBF0 LD A,($C3A0)  ;current weapon code
      CP $03        ;check if it is 'bolt'
      JR Z,$BC14
      CP B          ;check if collected current weapon
      JR NZ,$BC01
;collected currently carried weapon, so increase strength
      LD A,(HL)     ;load current weapon strength
      INC A         ;increase
      CP $09        ;check if max
      JR Z,$BC01
      LD (HL),A     ;store increased strength
$BC01 LD A,B
      LD ($C3A0),A  ;update current weapon
      LD ($C3A1),A  ;??
      CALL $AE9C    ;calculate full (multiplied) strength for current weapon in reg A
      LD ($C3A5),A  ;store full strength of current weapon here
      CALL $C113    ;draw current weapon and strength for all weapons
      JP $BB2B      ;return to collected object loop
;carrying a bolt weapon
$BC14 RES 7,(IX+$00);mark object as 'not collected'
      XOR A
      LD ($A25C),A  ;don't play any sound
$BC1C JP $BB2B      ;return to collected object loop

----------------------
;$BC1F : handler for collecting diamonds

$BC1F LD A,($C3A6)  ;current amount of diamonds
      INC A         ;increment
      LD ($C3A6),A  ;write back
      CP $08        ;check if 8
      JR Z,$BC30
      CALL $C0CF    ;set the color of last collected diamond on the indicator
      JP $BB2B      ;return to collected object loop
;collected 8 diamonds, need to clear indicator and add one life
$BC30 CALL $C0DC    ;clear all the diamonds on the indicator
      LD HL,$C3A7   ;current lives
      INC (HL)      ;increment
      CALL $C0C2
      LD A,$02
      LD ($A25C),A  ;play sound
$BC3F JP $BB2B      ;return to collected object loop

----------------------
;$BC42 : handler for collecting elemental piece

$BC42 LD A,($C3A8)  ;current number of elemental pieces
      INC A         ;increment
      LD ($C3A8),A  ;write back
      CP $06        ;check if all pieces have been collected
      JR NZ,$BC65
      LD A,$04
      LD ($A25C),A  ;play sound
      LD A,($C3A0)  ;current weapon
      LD ($C3A1),A  ;remember here
      LD A,$03      ;code for 'bolt' weapon
      LD ($C3A0),A  ;it becomes our current weapon
      LD A,$30
      LD ($C3A5),A  ;it has tremendous weapon strength
      CALL $C113    ;draw current weapon in weapon indicator
      CALL $C189    ;update elemental indicator: colour the collected piece
$BC68 JP $BB2B      ;return to collected object loop

----------------------
;$BC6B :

$BC6B LD A,(IX+$00) ;load object code
      RRCA
      RRCA
      RRCA          ;*8
      AND $0E       ;mask
      LD L,A
      LD H,$00      ;make it an offset
      LD BC,$BC7F   ;base addr
      ADD HL,BC
      LD E,(HL)     ;load handler's address low byte
      INC HL
      LD D,(HL)     ;load handler's address high byte
      EX DE,HL
BC7E: JP (HL)       ;jump to handler
----------------------
;$BC7F : secondary list of collecting object handler

----------------------
;$BDF7: Check if moving platforms are visible, and create a visible colliding object for them - BECF (+2)

;Scan a list of moving platforms, start loaded from ($C4CC). If platform becomes visible, create an entry
;in a list of visible colliding objects, which starts at $C3B5

$BDF7 LD A,($C4B0)   ;??
      CP 6
      RET Z
      LD IX,($C4CC)  ;load base address of list of scripted dynamic objects (clouds) for current level
      XOR A
      LD ($C4B6),A   ;reset
      INC A
      LD ($C4DA),A   ;
;loop
$BE09 LD A,(IX)      ;read status
      AND A
      RET Z          ;return if reached the end of a list (0)
      LD BC,$1810    ;size
      CALL $C000     ;check if goes out of visible screen
      JR NC,$BE7E    ;if not visible, skip this cloud
;cloud is visible, create an entry in list of visible colliding objects list
$BE16 EX DE,HL       ;save coordinates in D and E
      LD HL,$C3B5    ;base address of currently active visible objects list
      LD BC,$0C      ;structure size
$BE1D LD A,(HL)      ;check if inactive
      AND A
      JR Z,$BE24     ;found inactive structure, go
      ADD HL,BC      ;active, move to next
      JR $BE1D       ;loop
$BE24 LD A,(IX)      ;load status of scripted dynamic object (example: $05)
      AND 3          ;mask, keep two low bits
      DEC A          ;decrement
      OR 48          ;switch on bits 3 and 6
      LD (HL),A      ;into visible colliding object, byte + 0
      INC HL
      LD (HL),E      ;coordinate on screen into base + 1
      INC HL
      LD (HL),D      ;coordinate on screen into base + 2
      LD C,$46
      AND $03        ;mask A again, keep two low bits
      JR Z,$BE3E
      LD C,$45
      DEC A
      JR Z,$BE3E
      LD C,$44
$BE3E INC HL         ;+3
      INC HL         ;+4
      INC HL         ;+5
      INC HL         ;+6
      LD A,($C4B8)   ;???
      AND A
      JR Z,$BE4A
      LD C,$41
$BE4A LD (HL),C      ;depending on ($C4B8), either $41 or $44 go here, to base + 6
      INC HL
      LD (HL),$18    ;into +7
      INC HL
      LD (HL),$10    ;into +8
      LD HL,$C4BA
      INC (HL)       ;increment number of visible dynamic objects
      LD HL,($C3AA)  ;player's coordinates on screen
      LD A,H
      ADD A,$14      ;add width, reg a is a horizonal coord of right border of player's sprite
      SUB D          ;substract cloud's horizontal coord, so we have a difference between cloud's left border and player's right boder
      CP $28         ;if difference is less than cloud's width + player's width, then player is maybe standing on a cloud
      JR C,$BE6A     ;go if standing
      LD A,(IX+$00)
      AND $9F        ;if not standing, clear bits 5 and 6
      LD (IX+$00),A
      JR $BE7E
;player is above the cloud, so maybe he is standing on it
$BE6A LD A,L         ;vertical coord of player
      ADD A,$18      ;add height
      SUB E          ;subtract vertical coord of cloud
      JR Z,$BE97     ;if equals, player rides on a cloud
      JR NC,$BE89    ;go if player is now below the level of a cloud
;player is now above a cloud
      LD A,(IX+$00)  ;read previous cloud state
      BIT 5,A        ;check if player was below a cloud before
      JR NZ,$BE97    ;if he was (and now is above), then clouds moves up, so we are riding on it
      OR $40         ;we were above the cloud, so we are not riding it. Anyway, set the flag that we are above the cloud
      LD (IX+$00),A
$BE7E LD BC,$0009    ;structure size
      ADD IX,BC      ;move to next
      LD HL,$C4DA
      INC (HL)       ;increment total counter
$BE87 JR $BE09       ;loop

;player is now below the level of a cloud. It may be falling on a cloud too fast from above
$BE89 LD A,(IX+$00)
      BIT 6,A        ;check if player was above the cloud previously
      JR NZ,$BE97    ;if it was, then player fell on a cloud, and now he will ride on it
      OR $20         ;otherwise, set the flag that player is below the cloud
      LD (IX+$00),A  ;update cloud state
BE95: JR $BE7E       ;back to common code

;player is riding the cloud
;check if player hits the wall
$BE97 LD A,E         ;vertical coord of cloud
      SUB $18        ;subtract height of a player to get player's vertical coord
      LD E,A
      LD A,($C3AB)   ;horizontal coord of player
      LD D,A         ;here
      LD BC, $1818   ;size
      PUSH DE
      CALL $C858     ;scan blockset
      POP DE
BEA7: JR Z,$BEB7
;player rides the cloud and hits the wall
      XOR A
      LD ($C4BF),A   ;reset jump/fall frame
      LD A,(IX+$00)
      AND $9F        ;mask the state
      LD (IX+$00),A
      JR $BE7E       ;back to common code
;player rides the cloud and doesn't hit the wall
$BEB7 LD ($C3AA),DE  ;update coordinates
      XOR A
      LD ($C4BF),A   ;reset falling frame
      LD A,(IX+$00)  ;read status
      AND $9F        ;reset bit 5, since we are not below the level of a platform
      OR $40         ;switch on bit 6, that we are above or equal on platform
      LD (IX+$00),A  ;store back status
      LD A,($C4DA)   ;counter
      LD ($C4B6),A   ;save here as the number of platform player rides on
BECF: JR $BE7E       ;back to common code

----------------------
$BED1: Update coordinates of script-moveable dynamic objects (clouds) - $BFFD (+2)

For each level, there is a list of dynamic objects.
List entry format:
+0 (1 byte ) - ???, bit 2 shows direction
+1 (2 bytes) - coordinate A, variable
+3 (2 bytes) - coordinate B, variable
+5 (2 bytes) - speed table base pointer, constant
+7 (1 byte ) - current speed table entry offset.
+8 (1 byte ) - timer

Each object is moving in cycles. So, for each object there is a pointer to speed table, and current offset in this table.
Each speed table entry is:
+0 (1 byte) - two half-bytes are changes in coordinates A and B. They are added or subtracted, depending on direction bit
+1 (1 byte) - time length (initial value for timer).

So, cycles happen in a following way: while timer is decremented, a current value from speed table is used to change
the coordinates. When timer comes to 0, and direction bit is "normal", then move to next entry in speed table, and init the timer.
If next entry in speed table is special value "$FE", then set direction bit to "reverse", and start moving backwards in speed table.

If player is riding a platform, then player is moved. For vertical movement, player's coordinates are updated.
For horizontal movement,



$BED1 LD IX,($C4CC) ;load dynamic object coord/speed/time table base address (value is $E28B for level 1)
      LD D,1        ;initial index of dynamic object

;loop
$BED7 LD A,(IX)
$BED9 AND A         ;check if "end of speed and coord table" marker = 0
      RET Z         ;exit if it is
$BEDC LD L,(IX+5)   ;
      LD H,(IX+6)   ;HL contains speed table base
      LD A,(IX+8)   ;load "fast time" counter
      AND A         ;check if time period has ended
      JP Z,$BFB9    ;go if it is ended

;first branch, executed if time period has not ended yet
;read a value from speed table and update the coordinates
      DEC A         ;decrement timer
      LD (IX+8),A   ;and save back
      LD C,(IX+7)   ;time period index, works as offset in speed table
      LD B,0        ;in BC
      ADD HL,BC     ;add offset to base addr of speed table, points to current speed.
      LD A,(HL)     ;read value from that addr - current speed
;based on that value, modify two coordinate words: (IX+1)+(IX+2) and (IX+3)+(IX+4)
      BIT 2,(IX)    ;check second bit
      JR Z,$BEFC
      XOR $88       ;if not, then invert bits 3 and 7, they are used below
;low part (bits 0 - 3) of reg A will define on how much coord (IX+3)+(IX+4) will change
;this value is multiplied by 2, maybe inverted, and stored in HL
$BEFC LD C,A        ;save in C
      LD H,0
      AND 7         ;mask, keep low part (bits 0-3)
      JR Z,$BF0B    ;if 0, then skip the part
      ADD A,A       ;if not 0, *2
      BIT 3,C       ;check bit 3 (high bit of this part) in stored value
      JR Z,$BF0B    ;if 0, keep the value
      NEG           ;overwise invert
      DEC H         ;H will be $FF (inverted)
$BF0B LD L,A
      PUSH HL       ;save on stack
;high part (bits 4-7) of reg A will define on how much coord (IX+1)+(IX+2) will change
;this value is multipled by 2, maybe inverted, and stored in BC
      LD A,C        ;restore
      LD B,0
      AND $70       ;mask, keep bits 4,5,6
      JR Z,$BF21    ;if 0, skip the part
      SRL A
      SRL A
      SRL A         ;3 times shift to the left (so, it is in low part and is *2)
      BIT 7,C       ;check bit 7 (high bit of this part) of stored value
      JR Z,$BF21    ;if 0, keep the value
      NEG           ;overwise invert
      DEC B         ;B will be $FF (inverted)
$BF21 LD C,A
;add (or subtract, if it was inverted) BC to word in (IX+1),(IX+2)
      LD L,(IX+1)
      LD H,(IX+2)   ;read value (00B0)
      ADD HL,BC     ;add (or sustract, if inverted)
      LD (IX+1),L
      LD (IX+2),H   ;write modified value back
;add (or subtract, if it was inverted) HL to word in (IX+3),(IX+4)
      POP HL        ;restore HL from stack
      LD A,C        ;store C
      EX AF,AF'     ;in A'
      LD A,L        ;store L
      LD C,(IX+3)
      LD B,(IX+4)   ;read value
      ADD HL,BC     ;add (or subtract, if it was inverted)
      LD (IX+3),C
      LD (IX+4),B   ;write modified value back
      LD B,A        ;former L goes here
      EX AF,AF'
      LD C,A        ;restore C from A'

$BF43 LD A,($C4B6)  ;index of a platform player currently rides on
      CP D          ;compare with current moving object
      JR NZ,$BFB0   ;if not equal, skip the part below
      LD A,($C4B0)  ;game state
      AND A
      JP NZ,$BFB0   ;if not 0, skip the part below

;player is riding the platform, move player, and maybe move screen
;reg C contains vertical speed of a platform
;reg B contains horizontal speed of a platform
;horizontal and vertical movements are handled separatelly
      PUSH DE       ;store
;handle vertical movement
      LD DE,($C3AA) ;load player's coordinates
      LD A,C        ;platform's vertical speed
      AND A
      JR Z,$BF80    ;go if 0
      ADD A,E
      LD E,A        ;add to player's coordinate (try to move player standing on a cloud)
      PUSH BC       ;save
      LD BC,$1818   ;player's sprite size
$BF5E CALL $C858    ;check if player will hit the wall
      POP BC        ;restore
      LD DE,($C3AA) ;???
      JR NZ,$BF8B   ;go if player will hit the wall
;no, player has not hit the wall, and it rides the platform. Need to update coords and move the screen
      BIT 7,C       ;check platform's speed sign
      JR Z,$BF77    ;go if moving down
;platform is moving up
$BF6C CALL $C991    ;player rides on a cloud up, move screen up
      JR Z,$BF80    ;if screen was moved, go
      INC C
      INC C         ;decrement speed
$BF73 JR NZ,$BF6C   ;keep moving the screen, until speed value becomes 0
      JR $BF80
;platform is moving down
$BF77 CALL $C9CF    ;move screen down
$BF7A JR Z,$BF80    ;if screen was moved, go
      DEC C
      DEC C         ;decrement the speed
      JR NZ,$BF77   ;keep moving the screen, until speed value becomes 0
$BF80 LD DE,($C3AA) ;re-load player's coords
      LD A,E
      ADD A,C       ;add movement offset
      LD E,A
      LD ($C3AA),DE ;write back
;handle horizontal movement
$BF8B LD A,B        ;platform's horizontal speed
      AND A
      JR Z,$BFAF    ;go if 0
      ADD A,D       ;add to player's coordinate
      LD D,A
      PUSH BC
      LD BC,$1818   ;player's sprite size
$BF95 CALL $C858    ;check if moved player will hit the wall
      POP BC
      JR NZ,$BFAF   ;go if it will
      BIT 7,B       ;check speed direction bit
      JR Z,$BFA8
$BF9F CALL $C950    ;move screen to the left
      INC B         ;increment the speed
      INC B
      JR NZ,$BF9F   ;keep moving the screen, until speed value becomes 0
      JR $BFAF
$BFA8 CALL $C924    ;move screen to the right
      DEC B         ;decrement the speed
      DEC B
$BFAD JR NZ, $BFA8  ;keep moving the screen, until speed value becomes 0
$BFAF POP DE        ;restore D - index of dynamic object
$BFB0 INC D         ;increment index
      LD BC,9       ;structure size
      ADD IX,BC     ;move to next struct
$BFB6 JP $BED7      ;loop
;end of first branch

;second branch, executed when time period has ended
$BFB9 LD A,(IX+7)   ;read time period index,
      BIT 2,(IX)    ;direction bit. if 0, value of (IX+7) will be either +2, if 1, then -2
      JR Z,$BFC4
      SUB $04
$BFC4 ADD A,$02
      CP $FE        ;check if previous value was 0, and it was decremented. So, was moving backward in speed table, and just reached the beginning
      JR Z,$BFEE
      LD (IX+$07),A ;store modified time period index
      LD C,A
      LD B,$00      ;and use it as offset in speed table
      ADD HL,BC     ;add to base addr of speed table
      LD A,(HL)     ;read speed
      CP $FF        ;this marker means: change the direction from reverse to normal. Replaced with $FE
      JR Z,$BFEE
$BFD6 CP $FE        ;this marker means: reverse.
      JR NZ,$BFE6

;was moving in normal direction in speed table, and reached "reverse" flag
;will move backwards in speed table and invert all values when they are read
      SET 2,(IX+$00);set the "reverse" bit
      LD L,(IX+$05)
      LD H,(IX+$06)
$BFE4 JR $BFB9      ;check next entry in speed table. Since reverse bit is set, will go to previous entry in speed table.

;jumps here for all normal speeds.
$BFE6 INC HL        ;after speed, a time length is stored, HL points to it
      LD A,(HL)     ;load value
      LD (IX+$08),A ;store it as an initial value of time counter
$BFEB JP $BEDC      ;back to loop

;was moving in reverse direction in speed table, or reached special $FF flag
;will change flag to moving in normal direction
$BFEE LD A,$FE
      LD (IX+$07),A ;set the marker anyway
      RES 2,(IX)    ;reset the bit
      LD L,(IX+$05)
      LD H,(IX+$06)
$BFFD JP $BFB9      ;check next entry in speed table
;end of second branch


--------------------------
$C000 - Check if dynamic scriptable object (cloud) is visible on screen  - C03C

Params:
reg IX points to object's structure
reg B - horizontal size of dynamic object
rec C - vertical size of dynamic object

returns: CF is set if object is visible, H,L - coordinates on a screen

$C000 LD DE,($C4E0)  ;value to subtract - horizontal coord of screen in pixels
      LD L,(IX+3)
      LD H,(IX+4)    ;read value from structure - ??full horizontal coord of object in pixels??
      AND A
      SBC HL,DE      ;subtract, get horizontal offset of ?left? border of dynamic object from left border of screen
      LD A,L
      EX AF,AF'      ;save result in A'
      LD E,B
      LD D,0         ;move horizontal size into DE
      ADD HL,DE      ;add
      LD A,B         ;into reg A
      ADD A,$C8      ;add ??horizontal width of visible screen??
      LD E,A         ;into E (reg D is 0)
      AND A
      SBC HL,DE      ;subtract, get horizontal offset of right border of dynamic object from right border of screen
      RET NC         ;return if less

      LD DE,($C4E2)  ;value to subtract - vertical coord of screen in pixels
      LD L,(IX+$01)
      LD H,(IX+$02)  ;read value from structure - ??full vertical coord of object in pixels??
      AND A
      SBC HL,DE      ;subtract, get vertical offset of ?top? border of dynamic object from top border of screen
      LD A,L         ;copy result
      ADD A,$10      ;add ?? two slices ??
      LD B,A         ;save here
      LD E,C
      LD D,$00       ;move vertical size into DE
      ADD HL,DE      ;add
      LD A,C
      ADD A,$80      ;add ??vertical size of visible screen??
      LD E,A         ;into E
      EX AF,AF'      ;restore result
      ADD A,$18      ;add ?
      AND A
      SBC HL,DE      ;substract
      LD H,A
      LD L,B
$C03C RET

--------------------------
$C03D - check if two rectangles intersect - $C054

Params:
DE: coords of first rectange's left upper corner, example: $1F60
HL: coords of second rectangle's left upper corner, example: $DE50
BC,B'C' = sizes of first and second rectangles

$C03D LD A,D
      SUB H          ;compare D and H
      JR C,$C051
      EXX
      SUB B          ;subtract size
      EXX
$C044 RET NC         ;return if don't intersect
      LD A,L
      SUB E          ;compare L and E
      JR C,$C04B
      SUB C          ;subtract size
$C04A RET            ;return, carry flag means intersect
$C04B NEG            ;negate
      EXX
      SUB C          ;subtract size
      EXX
$C050 RET            ;return, carry flag means intersect
$C051 NEG            ;negate
      SUB B          ;subtract size
$C054 JR $C044

--------------------------
$C097: Reset score and print it  - $C0B4

$C0AB: Second entry point, just print the score

;reset the score
$C097 XOR A          ;fill memory with 0
      LD HL,$C330    ;from this addr
      LD B,06        ;length (6 digits)
      CALL $C512     ;fill the memory

;Second entry point, draw the score on screen
$C0A0 LD B,06        ;6 digits to draw
      LD DE,$C335    ;set pointer to the end of ares
      LD HL,$4033    ;addres in video memory
      LD ($C32B),HL  ;for printing
;print loop
$C0AB LD A,(DE)      ;get symbol
      EXX            ;save all regs except A
      CALL $C2F3     ;print symbol (code 0 for symbol "0")
      EXX            ;restore regs
      DEC DE         ;to previous digit
$C0B2 DJNZ $C0AB     ;end of loop
$C0B4 RET            ;exit

--------------------------
$C0B5: Draw one symbol at specific place ? - $C0BF (+2)

Param - ($C399) 

$C0B5 LD A,($C399)   ;get symbol code (values: 0)
      INC A          ;increment
      LD HL,$403B    ;pre-defined addr video mem pixel area addr
      LD ($C32B),HL  ;store as param
$C0BF JP $C2F3       ;draw symbol

--------------------------
$C0C2: Draw current number of lives - $C0CC (+2)

$C0C2 LD A,($C3A7)   ;get number of lives
      DEC A
      LD HL,$50A5    ;pre-defined addr video mem pixel area addr
      LD ($C32B),HL  ;store as param
$C0CC JP $C2F3       ;draw symbol

--------------------------
;$C0CF : set the color of last collected diamond on the diamond indicator - $C0DB
$C0CF LD B,$00
      LD HL,$C3A6    ;amount of diamonds addr
      LD C,(HL)      ;load amount of diamonds
      LD HL,$5824    ;attrib address
      ADD HL,BC      ;add as an offset
      LD (HL),$47    ;set the color of diamond
$C0DB RET

--------------------------
$C0DC: Clear colour for diamond indicator - $C0E7 (and control falls through)

$C0DC XOR A
      LD ($C3A6),A   ;amount of diamonds
      LD BC,$0701    ;B - width, C - height of diamond indicator
      LD A,42        ;will fill with these colours
      LD HL,$5825    ;address in attrib area

; control falls to next procedure, which fills attribute area and returns

--------------------------
$C0E8: Fill rectangle attrib area - $C0FB

Params: A - value to fill with.
        HL - memory area
        B - length, C - height

C times calls $C512 to fill the memory


--------------------------
$C0FC: Print two-digit number - $C110 (+2)

Input: HL - video mem addr to print to, A - value

$C0FC LD ($C32B),HL ;store address
;split value into two digits
      LD B,0        ;first (high) digit, 0 by default
$C101 SUB $0A       ;subtract 0A from reg A
      JR C,$C108    ;if less than 0, then A was less than 0A, break the loop
      INC B         ;if still greater than 0, then increment upper digit
      JR $C101      ;loop

$C108 ADD A,$0A     ;restore low digit, if we got below 0
      PUSH AF       ;store
      LD A,B
      CALL $C2F3    ;print high digit
      POP AF        ;restore
$C110 JP $C2F3      ;print, then ret. Shortcut for CALL $C2F3, RET 

--------------------------
$C113: Draw current weapon and stength for all weapons - $C16F

;print weapon strength
$C113 LD A,($C3A2) ;strength for arrows
      LD HL,$5099  ;video mem address where to print
      CALL $C0FC   ;print two-digit number
      LD A,($C3A3) ;strength for daggers
      ADD A,A      ;double it
      LD HL,$50B9  ;video mem address where to print
      CALL $C0FC   ;print two-digit number
      LD A,($C3A4) ;strength for axes
      LD B,A
      ADD A,A      ;double it
      LD B,A       ;triple it
      LD HL,$50D9  ;video mem address where to print
      CALL $C0FC   ;print two-digit number


$C132 LD A,($C3A0) ;current weapon
      AND $07      ;keep 3 bits
      LD C,A
      LD B,0       ; make it into offset in table
      LD HL,$C38C  ;table base
      ADD HL,BC    ;address in table
      LD C,(HL)    ;get value from table (for 01 - $44)
      LD HL,$C390  ;???
      LD (HL),C    ;store in ($C390)
      LD HL,$C336  ;some address
      LD ($CC81),HL;store here
      CP $03       ;compare
      JR NZ,$C14E  ;since sprite 3 is a gem, so
      INC A        ;weapon 3 (super-weapon) corresponds to sprite 4
$C14E LD HL,$775A  ;base address for weapon sprite
      LD C,$C0     ;size of all sprites for a weapon (B=0, BC=$00C0)
      INC A        ;A has weapon number + 1

;multiplication loop: calculates HL = HL + BC*A
$C154 ADD HL,BC    ;
      DEC A        ;
      JR NZ,$C154  ;
;end of loop. HL points to weapon sprite

$C158 LD A,$41     ;??
      LD ($CC7C),A ;attribute arg for draw proc
      LD IY,$C16F  ;jump destination after draw a sprite (points to RET)
      LD ($CA2B),IY;modify the code
      LD DE,$5488  ;video mem address, where to draw current weapon
      LD ($CC7F),DE;argument
$C16C JP $CCA3     ;draw weapon sprite
$C16F RET          ;will jump here from draw sprite (see $C15D). exit


--------------------------
;$C189 : Color collected elemental piece on indicator - $C19B (+2_

$C189 LD HL,$C3A8  ;
      LD C,(HL)    ;number of elemental pieces
      LD B,$00
      LD HL,$C390  ;base address
      ADD HL,BC    ;add as offset
      LD L,(HL)    ;load
      LD H,$5A     ;makes memory addr in attribute area
      LD A,$45     ;attrib value
      LD BC,$0202  ;width and heigth
$C19B JP $C0E8     ;fill rectangle

--------------------------
C19E: XOR A
      LD ($C3A8),A
      LD HL,$5A6D
      LD BC,$0604
      LD A,$41
C1AA: JP $C0E8
C1AD: LD ($C397),A
      XOR A
      LD ($C39A),A
C1B4: RET


--------------------------
$C19E: Reset elemental counter and their indicator - $C1AA (+2)

$C19E XOR A
      LD ($C3A8),A ;elemental counter
      LD HL,$5A6D  ;attrib memory area address for elemental indicator
      LD BC,0604   ;B - width, C - height
      LD A,$41     ;will fill with these colours
$C1AA JP $C0E8     ;jump to fill attrib rectangle proc

--------------------------
$C1AD: Prepare to print message on game screen - $C1B4

Param: reg A - message number

$C1AD LD ($C397),A  ;store message number
      XOR A
      LD ($C39A),A  ;time counter while message is visible
$C1B4 RET


--------------------------
$C1B5: Print at the center of a screen - $C1F4 (+2)

Param: ($C397) - message number, byte

$C1B5 LD A,($C397) ;number of a message
      AND A
      JR NZ,$C1C3  ;print, if not 0
      LD BC, $0190 
      LD D,$01     ;B,C,D - pause length
      JP $A4E2     ;pause and return
$C1C3 ADD A,A
      LD C,A
      LD B,0       ;bc = a*2 - offset
      LD HL,$C39A
      DEC (HL)
      DEC (HL)     ;decrement timer
      JR NZ,$C1D2
      XOR A        
      LD ($C397),A ;if time is out, set 0 as message number (don't print)
$C1D2 LD HL,$DBCC  ;message table base
      ADD HL,BC    ;add message offset
      LD A,(HL)    
      INC HL
      LD H,(HL)
      LD L,A       ;get message address
      PUSH HL      ;save
$C1DB CALL $C1F7   ;print

      POP DE       ;restore
      AND A        ;reset carry flag
      SBC HL,DE    ;subtract
      LD A,L
      SUB $18      ;
      RET NC       ;
      RET Z        ;exit if 
.....              ;calc pause value
$C1F4 JP $A4E2     ;pause and return

--------------------------
$C1F7: Draw a set of words on a screen with attribute - $C239

Input param: HL - address of a message. Attribute is first value
Attribute is read, stored in ($C32F)

$C1FC: Draw a set of words on a screen.

Input param: HL - address of a message.
Format is: two coordinates of a word, then symbols of a word. Last symbol
is marked with bit 7 set. Then next two coordinates, and next word. End
of message is marked by $FF.

$C1FC - $C120
Read a byte. If $FF, then exit immediatelly. Otherwise this is a horizonal coordinate.

$C201 - $C20F
Depending on bit 7 of coordinate, a call address at $C231 (2 bytes), which stores
the address of print procedure, is populated with either $C2E4 or $C280 
single or double-height procedures (self-modifying code).

$C210 - $C21C
Lower 5 bits are actual horizontal coordinate. Next byte is a vertical coordinate.
To calculate an address in pixel area of video mem, a call to $C2D5 is made.
Returned address is stored in ($C32B)

$C21D - $C229
For address in pixel area a corresponding address of attribute is calculated.
It is stored in ($C32D)

$C22A - $C239
A loop to print symbols by calling either $C2E4 or $C280 (see above at $C201-$C20F), 
until the one with 7 bit set is found, which means the end of a word.

--------------------------
$C23A: Раскрашивание нескольких прямоугольных областей атрибутов - $C24D (+1)

На входе: HL - "сценарий раскрашивания"

$C23A LD A,(HL)    ;Считывает цвет для окрашивания
$C23B INC HL
$C23C CP $FF       ;сравниваем с маркером конца
$C23E RET Z        ;если совпало - выходим

;Считывает BC, HL

$C247 PUSH HL      ;запоминаем позицию в "сценарии"
$C249 CALL $C0E8   ;заполнение области атрибутов
$C24C POP HL       ;восстанавливаем позицию в "сценарии"
$C24D JR C23A      ;повтор цикла

--------------------------
$C24F: ???  - $С27F


--------------------------
$C280: Print a double-height symbol - $С2С9

$C284 - $C290
If bit 6 is set, then this means 'move to the right', amount of moves is 
specified by lower 5 bits.

$C291 - $C2C9
Print a double height symbol. HL contains address in pixel area, DE contains address of symbol row,
B counts down from 4 to 1, each symbol row is transferred to two screen rows, 
next row is simply INC H. C counts down from 2 to 1 to track upper and lower halfs of symbol. To 
calculate pixel area address for a second half, a call to $C2CA is made.

--------------------------
$C2CA: Calculate a pixel area addr located 1 row below the last row of symbol  - $C2D4

Input: HL - pixel area addr for last, lowest row of symbol
Output: HL - pixel area addr for first, topmost row of symbol on next line

--------------------------
$C2D5: calculate address in pixel area of video mem for given coordinates - $C2E3

Input params: В - row, C - column.
Output: DE - address in pixel area

--------------------------
$C2E4: Print symbol with attribute - $C2F2

Input param: A - symbol code

Calls $C2F3 to draw symbol pixels

Variables:
($C32D) - 2 bytes, address in attribute area for symbol location. Will be incremented
($C32F) - 1 byte, value for attribute to be set

--------------------------
$C2F3: Draw symbol pixels - $C30D

Input params: A - symbol code. (Code 0 corresponds to "0", code 10 - "A", ...)

Constants:
$5BB0 - symbol table.

Variables:
($C32B) - 2 bytes, video mem pixel area address for output. Will be incremented at the end of procedure.

--------------
$C30E: ??? Draw score on a screen ??

$C30E LD HL,($C323) ;??
$C311 LD E,(HL)     ;first byte in reg E
      INC HL
      LD A,(HL)     ;next byte in reg A
      AND A
C315: JR NZ,$C31C   ;high byte is not 0, good value
      LD HL,$C325   ;high byte was 0, bad value, try from this address
      JR $C311      ;will loop forever
      INC HL
      LD D,A
      LD ($C323),HL ;store address here
      EX DE,HL      ;previous address into reg HL
$C322 JP (HL)       ;example value: $C0A0, draw the score on a screen


--------------
Variables:

$C32B (2) : video mem pixel area address for output for symbol print procedure $C2F3. Will be incremented at the end of procedure.
$C32D (2) : address in attribute area where symbol will be printed by symbol print procedure $C2E4. After output will be incremented
$C32F (1) : attribute value for symbol print procedure $C2E4

$C330 (6) : game score. 6 symbols

$C336 (?)

$C38C (?) : some table for weapons
$C390 (1) : current value obtained from table

$C397 (1) : number of message to print at the center of a screen
$C398 (1) : current level
$C399 (1) : ?

$C39C (?) : some table

$C3A0 (1) : current weapon

$C3A2 (1) : strength of arrows
$C3A3 (1) : strength of daggers (basic value, will be *2)
$C3A4 (1) : strength of axes (base value, will be *3)
$C3A6 (1) : amount of collected diamonds
$C3A7 (1) : current lives
$C3A8 (1) : number of collected elemental pieces

$C3A9 - player info in the same way as entry in the list of visible colliding objects (which starts at $C3B5)
$C3A9 (1) : status byte
$C3AA (1) : vertical coord of player on screen, in pixels
$C3AB (1) : horizontal coord of player on screen, in pixels

$C3B5 - list of visible colliding objects (monsters, missiles, clouds) excluding player
Entry size is $0C bytes. Entry format:
+0 (1) status, bit 7 if already handled
+1 (1) vertical coord in pixels
+2 (1) horizontal coord in pixels
+3 (1) ??
+5 (1) ??
+6 (1) ??
+7 (1) width in pixels
+8 (1) height in pixels
+9 - falling frame
+A
+B



$C439 : dynamic drawn object info drawing table for proc $C9F6
Entry format:
+0 (1) vertical line
+1 (2) video mem address
+3 (2) sprite address
+5 (2) attribs
+7 (2) drawing procedure



$C4A6


$C4AA (2)
$C4AC (2)
$C4AF (1) : player's sprite: step number (bits 0-2), sit (bit 6) and direction (bit 7, 1 - left, 0 - right)


$C4B0 (1) :  game state
$C4B1 (1) :  ??
$C4B3 (1) :  currently pressed logical keys: bit 0 - 'right', bit 1 - 'left', bit 2 - 'sit'
$C4B6 (1) :  index of platform player rides on
$C4B8 (1) :  ?? some flag


$C4BA (1) : number of visible colliding dynamic objects (monsters, missiles, clouds)
$C4BB (1) : ??
$C4BE (1) : ??
$C4BF (1) : current jumping/falling frame. Bit 7 indicates if it is jumping or falling (1 - falling).
            If jumping, table base is $C5CA, if falling, table base is $C5D8

$C4C1 (1) : ??
$C4C7 (1) : ?
$C4C8 (1) : shift accumulator

$C4CA (2) : pointer to statically placed collectable objects for current level
$C4CC (2) : pointer to scripted dynamic object (cloud) coord/speed/time table for current level
$C4CE (2) : result of searching for 0 from $E17A with step $06
$C4D0 (2) : result of searching for 0 from $DE52 with step $0A
$C4D2 (2) : result of searching for 0 from $DE2E with step $03
$C4D4 (2) : ?? timer counting down ??
$C4D6 (2) : ?? last random value ??
$C4D8 (2) : current sprite address for player
$C4DA (1) : misc temp variable used in different procedures:
             counter of colliding dynamic objects, to be handled
             counter of full horizontal blocks in row
$C4DB (1) : misc temp variable
$C4DC (2) : temp variable, offset from the beginning of a sprite

$C4E0 - number of pixels from left border of level to left border of screen
$C4E2 - number of pixels from top border of level to top border of screen
$C4E4 - (2) horizontal and vertical shift of upper left block in pixels from left and upper screen borders
$C4E6 (1) : horizontal movement of screen to the left since last time, in pixels
$C4E7 (1) : vertical movement of screen up since last time, in pixels
$C4E8 (2) : horizontal and vertical coordinates in labyrinth blocks of current upper left visible block
$C4EA - horizontal shift of block to the left, in pairs of pixels. Possible values from 0 to 4 (3?)
$C4EB - how many line-pairs to draw in top slice of each block (vertical shift of block up, in pairs of pixels). Possible values from 0 to 3
$C4EC - horizontal shift of blocks to the left, in 8-pixel bytes.
$C4ED - how many line-pairs to draw in second slice of each block. Possible values from 0 to 4 (3?)



--------------
$C4EE: Clear dynamic lists memory - $C50B

$C4EE LD HL,$C439
      LD DE,$C43A
      LD BC,$006C
      LD (HL),B
      LDIR         ;clear $6C+1 bytes starting from $C439, dynamic object info list (and till $C4A6)
      LD HL,$C3B5
      LD DE,$C3B6
      LD BC,$0083
      LD (HL),B
      LDIR         ;clear $83+1 bytes starting from $C3B5, visible colliding object info list (and till $C439)
      LD A,$80
      LD ($C4BF),A ;current jumping/falling frame
$C50B RET

--------------
$C50C: Init coordinates and shifts for new level - $C510 (falls through further)

from addr $C4E0 fill $0E bytes with value 0
falls to $C512 for actual fill

--------------
$C512: Fill memory with value - $C516 

Input: HL - addr, B - length, A - value.

--------------
;$C517: Calculate player's sprite address - $C563
;Params: ($C4AF) - player's state
;Result: ($C4D8) - player's sprite address

$C517 LD A,($C4AF)  ;player's state
      LD B,A        ;store
      LD HL,$9612   ;player's sprite base address
      AND $80       ;mask, keep bit 7 - direction
      JR Z,$C526
      LD DE,$0240   ;offset to add
      ADD HL,DE     ;if facing left, add offset to get to left-facing sprites
$C526 LD A,($C4B0)  ;??
      DEC A
      JR Z,$C555    ;jump if value was 1
      DEC A
      JR Z,$C555    ;jump if value was 2
      CP $03
      JR Z,$C555    ;jump if value was 5
      LD DE,$01E0   ;static offset for sitting sprite
      BIT 6,B       ;check sitting bit
      JR NZ,$C55F   ;go if sitting
      LD DE,$0180   ;static offset for jumping sprite
      LD A,($C4BF)  ;jumping/falling frame
      AND A         ;check if not 0
      JR NZ,$C55F   ;go if jumping or falling
      LD A,B
      AND $07       ;mask player's state, keep 'step'-bits
      SRL A
      RRCA
      RRCA          ;*8
      LD C,A
      LD B,$00      ;into BC, it will be offset
      ADD HL,BC     ;add to sprite base addr
      RRCA          ;*16
      LD C,A        ;update offset
      ADD HL,BC     ;add again, now points to correct sprite
      LD ($C4D8),HL ;save sprite address here
$C554 RET
$C555 LD HL,$FF01
      BIT 7,B       ;depending on direction bit
      JR Z,$C560
      LD DE,$0060
$C55F ADD HL,DE
$C560 LD ($C4D8),HL ;save sprite address here
$C563 RET

------------------
$C564 - C572 : Controller translation table, used by $C573. For 3 types of controllers contains 5 bytes, for each main keys



--------------
$C573: Keyboard query - $C5AE

Queries the keyboard, based on value of curent controller ($C4B2) (0, 1, 2)
result is stored in ($C4B3)

$C573 LD A,($C4B2)  ;current controller type
      LD HL,$C564   ;table base for controller type = 0
      AND A
      JR Z,$C590    ;go if controller type = 0
      LD HL,$C569   ;table base for controller type = 1
      DEC A
      JR Z,$C590    ;go
      LD HL,$C56E   ;table base for controller type = 2
      DEC A
      JR Z,$C590
      XOR A
      IN A,($1F)   ;read from port $001F
      AND $1F      ;mask
      LD E,A       ;into E
      JR $C59F     ;go
;HL contains translation table
$C590 LD D,$05     ;we need to query 5 main keys
      LD E,$00     ;bits of this reg will be flags for game keys
;key query loop
$C594 LD A,(HL)    ;read key row+number from the table
      INC HL
      CALL $C5AF
      CCF          ;invert carry flag
      RL E         ;make this flag as a bit in reg E
      DEC D        ;decrement key counter
      JR NZ,$C594  ;loop
$C59F LD A,$7F
      IN A,($FE)   ;read from this port
      CPL          ;complement
      AND $1F      ;mask
      LD A,E       ;load from reg E keys
      JR Z,$C5AB
      OR $10       ;make this bit if ??
$C5AB LD ($C4B3),A ;pressed keys
$C5AE RET

--------------
$C5AF: Keyboard query - $C5C9

Param: reg A (low half-byte is a number of row, high half-byte is a key)
returns: carry flag

$C5AF LD C,A       ;copy here
      AND 7        ;mask, keep 3 low bits
      INC A        ;increment, so starts with 1
      LD B,A       ;save here
      SRL C
      SRL C
      SRL C
      LD A,5
      SUB C
      LD C,A
      LD A,$FE     ;initial value
$C5C0 RRCA
      DJNZ $C5C0   ;loop, makes A as high byte of keyboard port address
      IN A,($FE)   ;read from port
;loop, rotate reg A and use reg C as a keyboard code
$C5C5 RRA
      DEC C
      JR NZ,$C5C5
$C5C9 RET

;--------------
;$C5E7 - handle moving left and right, jump, fall down and sit down, with collision detection - $C79D
;this procedure checks player's state in ($C4AF), ($C4BF) and, if appropriate, logical keys in ($C4B3)
;horizontal movement is handled even if player is jumping or falling
;it performs movement by updating following vars:
; player's state such as step number and direction in ($C4AF), jumping/falling status in ($C4BF)
; complex horizonal coord ($C4E9)+($C4EC)+($C4EA) and complex vertical coord ($C4E8)+($C4ED)+($C4EB)
; derived values: full horizontal coord ($C4E0), full vertical coord ($C4E2)
; player coords on a screen ($C3AA)
;also checks if player falls below the screen, or falls on spikes. In this case, status ($C4B0) is changed to 'death'
;if player walks over a teleport, this block is stored in ($A950)

$C5E7 LD A,($C4B0)  ;??? example: 0
      DEC A
      CP $0F
      RET C
      LD HL,$C4AF   ;player's sprite number (step number)
      LD A,($C4BF)  ;current jumping/falling frame
      AND A
      JR NZ,$C611   ;if not 0, then go to handle keys while jumping/falling

;we are not jumping or falling down
      LD A,($C4B3)  ;currently pressed keys
      BIT 2,A       ;check 'sit down' button
      JR Z,$C611    ;go if not
      AND $03       ;mask which will keep only keys 'left' and 'right'
      JR Z,$C60D    ;if neither 'left' nor 'right' are pressed, go just make it sit
      CP $03        ;check if both directions are pressed sumultaneously
      JR Z,$C60D    ;if yes, go just make it sit
      RES 7,(HL)    ;set direction to right
      DEC A
      JR Z,$C60D    ;and keep it, if only 'right' key was pressed
      SET 7,(HL)    ;otherwise, set direction to left
;'sit down' key was pressed
$C60D SET 6,(HL)    ;set the 'sit' flag
      JR $C651

;we are either normal and sit down is not pressed, or we are jumping, or falling down
$C611 LD DE,($C3AA) ;coords of player on screen
      LD BC,$1818   ;player sprite width and height, used by collision detection proc $C858
      LD A,($C4B3)  ;currently pressed keys
      AND $03       ;mask to keep only keys 'left' and 'right'
      JR NZ,$C627   ;go if some of them are pressed
$C61F LD A,(HL)     ;since HL has $C4AF, load player's sprite number (step number)
      AND $80       ;clean all except bit 7 (it's a direction left/right bit)
      OR $03        ;and set bits 0 and 1 (this step number is used for standing still)
      LD (HL),A     ;store back
      JR $C651

;keys 'left' or 'right' are pressed
$C627 CP $03
      JR Z,$C61F    ;go if both pressed simultaneously
      CP $02
      JR Z,$C640    ;go if 'left' key was pressed
;key 'right' was pressed
      LD A,(HL)     ;player's sprite number (step number)
      INC A         ;increment (makes player to step)
      AND $07       ;mask, so direction bit has value 'right'
      LD (HL),A     ;put back
      INC D
      INC D         ;increment horizontal coord twice, it is an arg for $C858
$C636 CALL $C858    ;scan blockset, check if we hit the wall
      JR NZ,$C651   ;if there is something, we can't move right, go to check jump/fall
$C63B CALL $C924    ;move screen to the right
      JR $C651      ;and go to check jump/fall
;key 'left' was pressed
$C640 LD A,(HL)     ;player's sprite number
      INC A         ;increment (makes player to step)
      AND $07       ;mask
      OR $80        ;set facing left
      LD (HL),A     ;store back
      DEC D         ;decrement horizontal coord
      DEC D         ;twice, it is an arg for $C858
$C649 CALL $C858    ;scan blockset, check if we hit the wall
      JR NZ,$C651   ;if hit the wall, we can't move to the left, go to check jump/fall
$C64E CALL $C950    ;move screen to the left

$C651 CALL $C819    ;coordinate calculation

$C654 LD A,($C4BF)  ;current jumping/falling frame
      AND A
      JR Z,$C6C5    ;go there if we are not already jumping or falling down
      BIT 7,A       ;check if we are jumping or falling
      JP NZ,$C6D1   ;go there if falling
;player is jumping
      LD E,A        ;goes here if jump
      LD D,$00      ;turn jump frame into offset, stored in reg DE
$C662 LD HL,$C5CA   ;base address of speed table??
      ADD HL,DE     ;add offset
      LD A,(HL)     ;read value from table - vertical speed ??
      CP $FF        ;check for special value - end of jump speed table
      JR NZ,$C673
      LD A,$80      ;we start falling - bit 7 is set, other bits are 0
      LD ($C4BF),A  ;save as jump/fall frame
      JP $C6D1      ;go to handle falling
;so, we are in jump
$C673 LD DE,($C3AA) ;coords of player on a screen
      PUSH AF       ;save jumping frame value
      SUB E
      NEG           ;subtract vertical speed from vertical coord, player goes up
      LD E,A        ;this is new vertical coord
      LD BC,$1818   ;rectangle size
      CALL $C858    ;scan level's blockset
      JR NZ,$C6B2   ;go if there is a collision
      LD HL,$C4BF
      INC (HL)      ;increment jumping frame
      POP AF        ;restore jumping speed
      LD B,A        ;copy here
      LD DE,($C3AA) ;coords of player on a screen
      SUB E
      NEG           ;substract speed from vertical coord
      CP $38        ;compare coord to this value
      JR C,$C69B    ;go if less
      LD E,A
      LD ($C3AA),DE ;store back vertical coord
$C69A RET
;jumps up too high, move visible screen up, vertical speed is a loop counter
$C69B PUSH BC       ;save loop counter
      CALL $C991    ;move visible screen up
      POP BC        ;restore loop counter
      JR Z,$C6A6    ;go there if can't move screen up, since reached top of the map
      DEC B         ;decrement loop counter once
      DJNZ $C69B    ;decrement second time and loop
$C6A5 RET
$C6A6 LD DE,($C3AA) ;get player coords on a screen
      LD A,E
      SUB B
      LD E,A        ;subtract speed from coord
      LD ($C3AA),DE ;write back
$C6B1 RET
;can't keep jumping, almost hit the ceiling
$C6B2 POP AF        ;restore vertical speed
      DEC A
      DEC A         ;decrement vertical speed twice
      JR NZ,$C673   ;more carefully check if hit the ceiling
;that's it, we hit the ceiling
      LD A,($C4BF)  ;current jumping frame
      SUB $0D
      NEG           ;dec from $0D
      OR $80        ;set 'falling down' flag
      LD ($C4BF),A  ;store
$C6C3 JR $C6D1      ;go to handle falling down

;we are not currently jumping or falling down
$C6C5 LD DE,$0000   ;initial jump frame in case we start jumping
      LD A,($C4B3)  ;currently pressed keys
      AND $08       ;check if 'jump' key is pressed
      JP NZ,$C662   ;go if 'jump' key is pressed, reg DE=$0000 contains initial jump frame
;will test if we came off the cliff and should start falling down
      XOR A         ;to check if we should start falling down, have fall down frame $00
;if we come here when we are falling, then reg A will contain value from ($C4BF) - fall down frame
$C6D1 AND $7F       ;mask, we don't need bit 7
      LD E,A
      LD D,$00      ;make it as offset
      LD HL,$C5D8   ;base address, fall down speed table
      ADD HL,DE     ;add offset
      LD A,(HL)     ;read fall down speed. example value for frame $00: $02
      CP $FF        ;special value: end of table. Previous entry will be used
      JR NZ,$C6E5
      DEC HL        ;decrement table pointer
      LD A,(HL)     ;read value
      LD HL,$C4BF
      DEC (HL)      ;decrement current frame
$C6E5 LD DE,($C3AA) ;player coords on a screen
      PUSH AF       ;save speed
      ADD A,E       ;add to vertical coordinate
      LD E,A
      LD BC,$1818   ;rectangle size
$C6EF CALL $C858    ;scan rectangle, check if we hit the ground (there are block under us)
      JR NZ,$C732   ;go if hit the ground
      LD A,($C4BF)  ;current falling frame
      INC A         ;increment
      OR $80        ;and always switch on bit 7 to indicate that we are falling down
      LD ($C4BF),A
      POP AF        ;restore speed
      LD B,A        ;copy speed here
      LD DE,($C3AA) ;player coords on a screen
      ADD A,E       ;add speed to vertical coord
      CP $59        ;check this special value
      JR NC,$C70E   ;jump if greater (on screen it means below row $59)
      LD E,A        ;otherwise, no need to scroll down
      LD ($C3AA),DE ;save coord back
$C70D RET
;we are falling, scroll screen down, falling speed is a counter loop
$C70E PUSH BC       ;save counter
      CALL $C9CF    ;move screen down
      POP BC        ;restore counter
      JR Z,$C719    ;go if cannot move down
      DEC B         ;decrement counter once
      DJNZ $C70E    ;decrement second time and loop
$C718 RET           ;return
$C719 LD DE,($C3AA) ;load coords
      LD A,E        ;vertical coord
      ADD A,B       ;add moving down
      LD E,A
      LD ($C3AA),DE ;store back
      CP $78        ;compare with bottom of a screen
      RET C         ;greater, all OK
      LD A,$03      ;dying, falling below a screen
      LD ($C4B0),A  ;save status
      LD A,$01
      LD ($A25C),A  ;?? sound of death ??
$C731 RET

;almost hit the ground
$C732 POP AF        ;restore speed
      DEC A
      DEC A         ;dec it twice
      JR NZ,$C6E5   ;if not 0, go back and keep falling
;that's it, we hit the ground
      XOR A         ;reg A = 0
      LD ($C4BF),A  ;set current jump/fall down frame to 0
      LD ($C4DA),A  ;??
;scan block row, addr in HL, width in B, accumulate if bits 7 and 4 are set
      PUSH HL       ;save block address
      LD D,B        ;save reg B here
$C740 DEC HL
      OR (HL)
      DJNZ $C740    ;loop
      POP HL        ;restore
      AND $90       ;apply mask (keep bits 7 and 4)
      LD C,A        ;save result here
      LD B,D        ;restore reg B
;scan the same block row, accumulate if bits 6 and 5 are reset
$C749 LD A,$60      ;initial value
;another loop
$C74B DEC HL
      AND (HL)
      DJNZ $C74B    ;loop
      OR C          ;combine with prev result
      LD E,A        ;save here
      BIT 7,E       ;check bit 7 of level blocks
      JR Z,$C760
      LD A,$02      ;death, walking over a spikes
      LD ($C4B0),A  ;into game status
      LD A,$01      ;?? this value
      LD ($A25C),A  ;?? goes here
$C75F RET
$C760 BIT 6,E       ;check bit 6 of level blocks
      JR Z,$C76F
      LD A,$03
      LD ($C4B0),A  ;death, falling through water
      LD A,$01
      LD ($A25C),A  ;?? sound of death ??
$C76E RET
$C76F BIT 5, E
      JR Z,$C77C
$C773 LD A,$04      ;walking over a teleport
      LD ($C4B0),A  ;save here
      LD ($A950),HL ;teleport's block address here
$C77B RET
$C77C BIT 4,E
      RET Z
$C77F LD A,$01      ;blocks under player are destructable
      LD ($C4DA),A
      LD B,D
$C785 BIT 4,(HL)
      JR Z,$C795
      XOR A
      LD (HL), A
      PUSH BC
      PUSH HL
      CALL $C79E    ;calculate block coordinates in pixels for current screen, HL -> H,L
      CALL $C7EC    ;turn level block into colliding object
      POP HL
      POP BC
$C795 INC HL
      DJNZ $C785
      LD A,$06      ;this sound
      LD ($A25C),A  ;to play
$C79D RET

--------------
;$C79E: calculate block coordinates in pixels for current screen - $C7D7
;
;param: HL, block address
;result: H: horizontal pixel coord, L: vertical pixel coord

$C79E LD DE,$9D72   ;start of level
      AND A
      SBC HL,DE     ;substract from block's address, gives index of given block from the beginning
      LD DE,$001E   ;width of level, in blocks
      LD C,$FF      ;row counter
$C7A9 SBC HL,DE     ;substract width
      INC C         ;inc row counter
      JR NC,$C7A9

      ADD HL,DE     ;since last substraction resulted with underflow, revert it, HL has column num
      LD DE,($C4E8) ;coords in blocks
      LD A,($C4E4)  ;vertical shift
      LD B,A        ;store here
      LD A,C        ;reg A has row of requested block
      SUB E         ;substract row of top visible block, reg A has visible row number for requested block
      ADD A,A
      ADD A,A
      ADD A,A
      ADD A,A       ;reg A = reg A * 16, since row height is 16 pixels
      ADD A,$0C     ; ??
      SUB B         ;substract vertical shift
      LD C,A        ;store here
      LD A,($C4E5)  ;horizontal shift
      LD B,A        ;store here
      LD A,L        ;reg A has column of requested block
      SUB D         ;substract column of left visible block, reg A has visible column number for requested block
      ADD A,A
      ADD A,A
      ADD A,A       ;reg A = reg A * 8
      LD D,A        ;store here
      ADD A,A
      ADD A,A       ;reg A = original reg A * 32
      ADD A,D       ;reg A = original reg A * 40, since block is 40 pixels wide
      ADD A,$18     ;??
      SUB B         ;substract horizontal shift
      AND $F8       ;?? mask, clear 3 low bits
      ADD A,$08     ;??
      LD H,A        ;store here horizontal pixel coord for block
      LD L,C        ;put here vertical pixel coord for block
$C7D7 RET

--------------
;$C7D8: ?? - $C7EB

C7D8: LD DE, $9D72
C7DB: AND A
C7DC: SBC HL, DE
C7DE: LD C, $FF
C7E0: LD DE, $001E
C7E3: SBC HL, DE
C7E5: INC C
C7E6: JR NC, $C7E3
C7E8: ADD HL, DE
C7E9: LD H, L
C7EA: LD L, C
C7EB: RET

--------------
;$C7EC: We just hit the destructible level block, turn it into colliding object - $C818
;Param: HL - coords of block in pixels, reg H has horizontal coord, reg L has vertical coord

$C7EC EX DE,HL      ;put coords in DE
      LD HL,$C3B5   ;list of visible colliding objects
      LD BC,$000C   ;list entry size
$C7F3 LD A,(HL)     ;read status byte for entry
      AND A
      JR Z,$C7FA    ;if 0, we found a free entry
      ADD HL,BC     ;otherwise, move to next list entry
      JR $C7F3      ;loop
$C7FA LD A,$C8      ;?? some constant
      LD (HL),A     ;base+0, write here
      INC HL
      LD (HL),E     ;base+1, vertical coord
      INC HL
      LD (HL),D     ;base+2, horizontal coord
      INC HL
      LD (HL),$04   ;base+3, ??
      INC HL
      INC HL
      LD (HL),$4A   ;base+5 ??
      INC HL
      LD A,($C4B8)  ;?? depending on this value
      AND A
      LD A,$45      ;?? either this will be written
      JR Z,$C813
      LD A,$41      ;?? or this will be written
$C813 LD (HL),A     ;base+6, write
      LD HL,$C4BA   ;counter of dynamic visible objects
      INC (HL)      ;increment
$C818 RET

--------------
;$C819: Coord calculation - $C857

;based on complex horizonal coord ($C4E9)+($C4EC)+($C4EA) and complex vertical coord ($C4E8)+($C4ED)+($C4EB)
;updates full horizontal coord ($C4E0), full vertical coord ($C4E2) and ?? values in ($C4E4)

$C819 LD A,($C4EC)  ;horizontal shift in 8-pixel bytes to the left, values from 0 till 4, since block is 5 bytes wide
      ADD A,A
      ADD A,A
      ADD A,A       ;*8
      LD H,A        ;store in reg H
      LD A,($C4EA)  ;horizontal shift in pixel pairs, values from 0 till 3
      ADD A,A       ;*2
      ADD A,H       ;add
      LD D,A        ;into reg D
      LD A,($C4ED)  ;vertical shift
      ADD A,A       ;*2
      LD L,A        ;into L
      LD A,($C4EB)  ;vertical shift
      ADD A,A       ;*2
      ADD A,L       ;add
      LD E,A        ;into E
      LD ($C4E4),DE ;save
      LD A,($C4E9)  ;horizontal coord in blocks
      LD H,0 
      LD B,H
      ADD A,A
      ADD A,A
      ADD A,A       ;*8 (8 pixels in byte)
      LD C,A
      LD L,A
      ADD HL,HL
      ADD HL,HL
      ADD HL,BC     ;*5 (5 bytes in block), total *40
      LD C,D
      ADD HL,BC     ;add horizontal shift
      LD ($C4E0),HL ;store full horizontal coord (number of pixels from left border of level to left border of screen)
      LD A,($C4E8)  ;vertical coord in blocks
      ADD A,A
      ADD A,A
      ADD A,A       ;*8 (height of layer)
      LD L,A
      LD H,0
      ADD HL,HL     ;and *2 (2 layers in block), total *16
      LD C,E
      ADD HL,BC     ;add vertical shift
      LD ($C4E2),HL ;store full vertical coord (number of pixels from top border of level to top border of screen)
$C857 RET

--------------

;$C858 - Convert screen rectangle to rectanglular blockset and scan it - $C8CC

;reg D - horizontal coord in pixels of left border of rectangle, from left border of screen
;reg E - vertical coord in pixels of upper border of rectangle, from top border of screen
;reg B - width of rectangle in pixels
;reg C - height of rectangle in pixels

;returns: HL - block address
;B,C - blockset width and height in blocks
;A and flags, NZ if blockset is not empty

;calculate vertical coord of upper part of blockset in blocks, from upper visible block, in reg E
;and height of blockset, in blocks, in reg C
$C858 LD A,($C4E4)  ;vertical shift of upper visible blocks in pixels from border of a screen
      LD L,$0F      ;mask value
      ADD A,E       ;add vertical pixel coord
      LD H,A        ;save
      RRA
      RRA
      RRA
      RRA           ;rotate 4 times to the right
      AND L         ;mask, keep low 4 bits (so div by 16, gives coord in blocks, since each block is 16 pixels high)
      DEC A         ;dec
      LD E,A        ;save this result (vertical coord in blocks of top of blockset)
      LD A,H        ;restore saved value
      AND L         ;mask, keep low 4 bits
      ADD A,C       ;add height of rectangle
      DEC A         ;dec
      RRA
      RRA
      RRA
      RRA           ;rotate 4 times
      AND L         ;mask, keep low 4 bits
      INC A         ;inc
      LD C,A        ;save this result (height of blockset, in blocks)

;calculate horizontal coord of left border of blockset in block, from left visible block, in reg D
;and width of blockset, in blocks, in reg B
      LD H,$28      ;init H, width of block in pixels $28 = 5*8
      LD A,($C4E5)  ;horizontal shift of left visible block from border of a screen
      ADD A,D       ;add horizontal pixel coord
      LD D,$FF      ;init D
      JR NC,$C87F
      SUB $18
$C87D JR $C883
$C87F SUB $18
      JR C,$C89D
$C883 INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
      JR C,$C89D
      INC D         ;increment horizontal coord in blocks
      SUB H         ;decrement coord in pixels by width of block
;at this point reg A contains negative value
$C89D ADD A,H       ;add back width of block in pixels
      ADD A,B       ;add width of rectangle
      DEC A         ;dec by one pixel
      LD B,$01      ;default width of blockset is 1 block
      SUB H         ;substract width of block
      JR C,$C8A6    ;if again we got negative value, then width of blockset is 1 block
      INC B         ;otherwise, width of blockset is 2 blocks

;at this point reg B and reg C contain width and heigth of blockset in blocks
;reg D and reg E should contain horizontal and vertical number of blocks from upper left visible block
$C8A6 LD HL,($C4E8) ;coords of upper visible labyrinth block
$C8A9 CALL $C8CD    ;calculate block's address, returns in HL, regs BC are preserved
      LD E,$00      ;initial value for scanning a blockset ($00)
      LD D,B        ;inner loop counter value
      LD A,C        ;save reg C
      EX AF, AF'    ;into A'
$C8B1 JR $C8BC

;scan a rectangular blockset, upper left corner addressed by HL, width in blocks in reg D, height in blocks in reg C
;outer loop
;update HL, so it points to left block in next row of blockset
$C8B3 LD A,$1E      ; ?? horizontal size of level
      SUB D         ;decrement by width of scanning area
      ADD A,L
      LD L,A        ;update low byte
      LD A,$00
      ADC A,H
      LD H,A       ;if there was a carry, add it to high byte of addres
;loop entry point is here
$C8BC LD A,E       ;restore accumulated scan result
      LD B,D       ;restore inner loop counter (horizontal size of blockset)
;inner loop: scan row of blocks (size = reg D) from left to right, accumulating result in reg A
$C8BE OR (HL)
      INC HL
$C8C0 DJNZ $C8BE   ;inner loop
      LD E,A       ;save accumulated scan result
      DEC C        ;decrement vertical counter (counter of rows)
$C8C4 JR NZ,$C8B3  ;outer loop

      EX AF,AF'
      LD C,A       ;restore reg C (height in blocks)
      LD B,D       ;restore reg B (width in blocks)
      EX AF,AF'    ;restore scan result
      AND $0F      ;mask
$C8CC RET

--------------
;$C8CD: Calculate address of block - $C8E0
;
;Params: H,D - horizontal coords in blocks, L,E - vertical coords in blocks
;Returns: block address in HL

$C8CD LD A,L
      ADD A,E
      ADD A,A      ;A = (L + E)*2, we need to *2 since each addr takes 2 bytes
      LD L,A       ;to L
      LD A,H
      ADD A,D      ;A = H + D
      LD H,0       ;H to 0
      LD DE,$C8E1  ;table base
      ADD HL,DE    ;add doubled vertical coords as offset
      LD E,(HL)
      INC HL
      LD D,(HL)    ;DE contains two bytes from table: address of leftmost block for given vertical coords
      LD L,A
      LD H,0       ;reg HL now contains sum of horizontal coords
      ADD HL,DE    ;add horizontal coords to get block's address
$C8E0 RET
--------------
;$C8E1: Table with precalculated addresses of leftmost blocks - $C920
;       values: $9D72,$9D90,$9DAE,$9DCC. diff - 1E
;       Total 129 pair of bytes

--------------
;$C924: Horizontal move of visible screen to the right - $C94D
;moves by one pixel pair
;updates complex horizonal coord stored in vars ($C4E9)+($C4EC)+($C4EA)

$C924 LD HL,($C4E8)
      LD A,H            ;horizontal coord in level blocks
      CP $19
      RET Z             ;exit with ZF if reached right border
      LD A,($C4E6)      ;horizontal movement of screen to the left since last time, in pixels
      SUB 2             ;decrement
      LD ($C4E6),A      ;store back
      LD A,($C4EA)      ;horizontal shift in pixel pairs
      INC A             ;increment
      AND 3             ;mask
      LD ($C4EA),A      ;store back
      RET NZ            ;it's still not 0, return
      LD A,($C4EC)      ;it became 0, so increment shift in bytes
      INC A
      LD ($C4EC),A      ;write back
      CP $05            ;have we moved the whole block size?
      RET NZ            ;no, return
      XOR A
      LD ($C4EC),A      ;reset shift in bytes to 0
      INC H
      LD ($C4E8),HL     ;increment horizontal coord in level blocks
$C94F RET

--------------
;$C950: Horizontal move of visible screen to the left - $C990
;moves by one pixel pair
;updates complex horizonal coord stored in vars ($C4E9)+($C4EC)+($C4EA)

$C950 LD HL,($C4E8)     ;horizontal coord in level blocks
      LD A,($C4EC)      ;horizonal shift in bytes
      LD D,A
      LD A,($C4EA)      ;horizontal shift in pixel pairs
      LD E,A
      OR D
      OR H
      RET Z             ;do nothing if all of them are 0
      LD A,($C4E6)      ;horizontal movement if screen since last time, in pixels
      ADD A,$02         ;increment
      LD ($C4E6),A      ;store back
      LD A,E            ;horizontal shift in pixel pairs
      DEC A             ;decrement
      AND $03           ;mask, so underflow makes it 3
      LD ($C4EA),A      ;store back
      CP $03            ;check if it was not 0
      RET NZ            ;if it was not, just exit
      LD A,D            ;otherwise, we need to decrement shift in bytes
      DEC A
      LD ($C4EC),A      ;store it back
      CP $FF            ;check it was not 0
      RET NZ            ;just exit if it was not 0
      LD A,$04          ;instead of underflow, use this value
      LD ($C4EC),A      ;store horizontal shift in bytes
      DEC H             ;and decrement horizontal coord in blocks
      LD ($C4E8),HL     ;store back
      CP $FF            ;check that it was not 0
      RET NZ            ;exit if it was not 0
      LD H,$00
      LD ($C4E8),HL     ;if it was 0, then jus overwrite all coords with 0
      LD A,H
      LD ($C4EA),A
      LD ($C4EC),A
$C990 RET               ;and exit
--------------
;$C991: Vertical move of visible screen up, all content goes down - $C9CE
;moves by one pixel pair
;Updates complex vertical coord stored in vars ($C4E8)+($C4ED)+($C4EB)
;also updates ($C4E7)

$C991 LD HL,($C4E8)     ;coords of upper left visible block in blocks
      LD A,($C4ED)      ;number of line-pairs in second slice
      LD D,A            ;into D
      LD A,($C4EB)      ;number of line-pairs in top slice
      LD E,A            ;into E
      OR D
      OR L
      RET Z             ;return if vertical coord in blocks and number of lines to draw is 0
      LD A,($C4E7)      ;vertical movement of screen since last time, in pixels
      ADD A,$02         ;add
      LD ($C4E7),A      ;store back
      LD A,E            ;number of line-pairs in top slice
      DEC A             ;dec
      AND $03           ;mask, keep two bits, since the value is 0-3
      LD ($C4EB),A      ;write back
      CP $03            ;check if it was 0
      RET NZ            ;exit if it was not 0
      LD A,D            ;number of line-pairs in second slice
      XOR $04           ;flip bit 3
      LD ($C4ED),A      ;write back
      CP $04            ;check if it was 0
      RET NZ            ;exit if it was not
      DEC L             ;decrement coord in blocks
      LD ($C4E8),HL     ;write back
      LD A,L
      CP $FF            ;check underflow
      RET NZ            ;exit if there were no underflow
      LD L,$00          ;if there was underflow, put 0 to all coords
      LD ($C4E8),HL
      LD A,L
      LD ($C4EB),A
      LD ($C4ED),A
$C9CE RET

--------------
;$C9CF: Vertical move of visible screen down, all content go up - $C9F5
;moves by one pixel pair
;Updates complex vertical coord stored in vars ($C4E8)+($C4ED)+($C4EB)
;also updates ($C4E7)

$C9CF LD HL,($C4E8)     ;coords of upper left visible block in blocks
      LD A,L            ;vertical coord in blocks
      CP $18            ;?? height of level in blocks ?
      RET Z             ;don't move down if reached this value ($18)
      LD A,($C4E7)      ;vertical movement of screen since last time, in pixels
      SUB $02           ;decrement by 2
      LD ($C4E7),A      ;write back
      LD A,($C4EB)      ;number of line-pairs in top slice
      INC A             ;increment
      AND $03           ;mask
      LD A,($C4EB),A    ;write back
      RET NZ            ;if it is not 0, then return, nothing more to update
      LD A,($C4ED)      ;number of line-pairs in second slice
      XOR 4             ;flip bit 3
      LD ($C4ED),A      ;write back
      RET NZ            ;return nothing more to update
      INC L             ;increment vertical coord in blocks
      LD ($C4E8),HL     ;write back
$C9F5 RET

--------------
$C9F6: Draw dynamic objects - $CA2D (+1)

Param: IY - return address

$C9F6 LD ($CA2B),IY ;modify the code, put return address

$C9FA: Second entry point

;platform draw loop
$C9FA LD HL,($CC81) ;pointer to struct holding dynamic drawn object info ($C439, $C442)
$C9FD LD A,(HL)     ;
$C9FE AND A         ;check if 0
$C9FF JR Z,$CA24    ;if it is 0, return with flag
      LD DE,($CC7A) ;E is a number of current 8-line row
      CP E          ;compare with vertical coord of an object
      JP NC,$CA29   ;object is higher, alrady drawn, skip
      LD IY,$C9FA   ;return addr for JP (IX) below, but points to the start of loop
      LD SP,HL      ;will use stack to read object info
      LD (HL),0     ;set byte 0, this object is drawn
      INC SP
      POP DE        ;read video mem addr
      LD ($CC7F),DE ;it's an argument for sprite-draw proc
      POP HL        ;sprite pointer
      POP BC        ;attribute
      LD ($CC7B),BC ;store B into $CC7C
      POP IX        ;platform/enemy drawing proc: $CD15, $CA2F
      LD ($CC81),SP ;store pointer to next platform
$CA22 JP (IX)       ;draw a platform. It will return to $C9FA
$CA24 LD A,$FF
$CA26 LD ($CC79),A  ;?? store the flag
$CA29 LD IY,$....   ;restore return address, this code is modified above
$CA2D JP (IY)       ;return

--------------

$CA2F - Draw platform/enemy sprite - $CB6D

IY - return address
DE - video addr?
HL - sprite addr

Heavily uses code modification with values stored in table at $CC83

$CA2F LD BC,$0C04
      LD ($CC7D),BC ;04 - default visible width of a sprite, 0C - default height of a sprite
      LD A,($CC7B)  ;?? value example - $28
      CP $10
      JP C,$CA64
      CP $FA
      JP NC,$CA64
      CP $7A
      JP NC,$CA7F
$CA48 LD ($CB6B),IY ;modify the code: save return addr
      LD A,($CC7C)  ;attrib
      AND $7F
      LD ($CB01),A  ;modify the code, set attribute
      LD A,E        ;check lower byte of video memory
      AND $1F       ;mask, keep 5 low bits
      CP $03        ;check if it is less than $03
      JP C,$CA8A    ;less, sprite is partly visible and to the left of a screen, jump
      CP $19        ;check if it is greater than or equal $19
      JP NC,$CA99   ;greater or equal, sprite is partly visible and to the right of a screen, jump
      JP $CAA0      ;sprite is in the center of a screen
$CA64 ADD A,$08
      LD B,A        ;number of lines in sprite
      RRCA          ;/2
      LD ($CC7E),A  ;number of line-pairs in sprite
      LD A,$18

;additional entry point.
;Args are: reg HL, reg B, reg A and ($CC7E)
$CA6D SUB B         ;A = A - B
      ADD A,A
      ADD A,A       ;*4
      LD C,A
      LD B,$00      ;into BC, offset
      ADD HL,BC     ;add to sprite start
      LD A,E
      AND $1F
      OR $40
      LD E,A
      LD D,$40      ;modify video-mem addr
$CA7C JP $CA48

$CA7F SUB $90
      NEG
      RRCA
      LD ($CC7E),A
$CA87 JP $CA48

;sprite is partly visible, in the left part of a screen
$CA8A INC A
      LD ($CC7D),A  ;visible width of a sprite, store
      DEC A
      XOR $03
      LD B,A
;skip invisible part of the sprite
$CA92 INC E
      INC HL
$CA94 DJNZ $CA92
$CA96 JP $CAA0

;sprite is partly visible, in the right part of a screen
;skip invisible part of the sprite
$CA99 SUB $1C
      NEG           ;A = $1C - A,
      LD ($CC7D),A  ;visible width of a sprite, store

;code modification magic
;read code modification locations from a table, and patch the code
$CAA0 LD ($CC7F),DE ;store video mem address
      EXX           ;switch registers
      LD A,($CC7D)  ;restore, visible width of a sprite, in bytes
      ADD A,A
      ADD A,A
      ADD A,A       ;*8
      LD HL,$CC7B   ;base, but since A cannot be 0, the real data start from $CC7B + 1*8 = $CC83
      LD C,A
      LD B,$00      ;BC - offset
      ADD HL,BC     ;HL points to code modification table, example value - $CC83
      LD SP,HL      ;will read from memory using stack
      POP IY        ;get location (example value - $CB1D)
      LD ($CB5F),IY ;modify the code which modifies the code, a location to patch later
      POP IX        ;get location (example value - $CB38)
      LD ($CB66),IX ;modify the code which modifies the code, a location to patch later
      LD SP,IY      ;will write to memory using stack, will patch code at location loaded in IY
      LD BC,$E9FD   ;opcode for "JP (IY)"
      PUSH BC       ;patch it
      LD SP,IX      ;will patch code at location loaded in IX
      LD C,$DD      ;opcode for "JP (IX)"
      PUSH BC       ;patch it
      LD SP,HL      ;restore
      POP AF        ;skip those, already used them just above
      POP AF
      POP IY        ;for a code which draws a first line: where to jump to skip invisible part of a sprite
      POP IX        ;for a code which draws a second line: where to jump to skip invisible part of a sprite

;video mem and sprite addr calculations
$CAD1 LD DE,($CC7F)
      LD A,($CC7E)
      LD B,A
      RLCA
      DEC A
      SRL A
      SRL A
      SRL A
      INC A
      LD C, A
      LD A, B
      CP $0C
      JR C,$CAEF
      LD A,D
      AND $07
      JP Z,$CAEF
      INC C
$CAEF LD A, D
      RRCA
      RRCA
      RRCA
      AND $03
      OR $58
      LD D,A
      LD HL,($CC7D)
      LD A,$20
      SUB L
$CAFE LD H, A

;attribute lines loop
$CAFF LD B,L
;attribute line loop
$CB00 LD A,??     ;attrib value, this code is modified above (value example - $46)
      LD (DE),A   ;write
      INC E       ;to next attrib
      DJNZ $CB00  ;loop
      LD A,E
      ADD A,H
      LD E,A
      LD A,B
      ADC A,D
      LD D,A
      DEC C
$CB0D JP NZ,$CAFF ;loop

$CB10 EXX
$CB11 LD A,($CC7E);number of line-pairs
$CB14 LD B,A      ;will use it as loop counter
;this code can be modified: an instructions "JP (IY)" and "JP (IX)" may be inserted to avoid drawing parts of a sprite
;IX and IY will be pre-set to jump somewhere to INC HL set of instructions, which will just skip sprite bytes
;loop: draw sprite by line-pairs
$CB15 LD C,E      ;save low byte of video-mem addr, so we can return back to the left part of sprite
;first line of up to 5 bytes
$CB16 LD A,(DE)   ;read byte from video-mem
      XOR (HL)    ;compose with sprite byte
      LD (DE),A   ;write back to video-mem
      INC HL      ;to next sprite byte
      INC E       ;to next (right) video-mem addr
$CB1B LD A,(DE)   ;handle second byte (!!this code can be modified, may be replaced with "JP (IY)")
      XOR (HL)
      LD (DE),A
      INC HL
      INC E
$CB20 LD A,(DE)   ;handle third byte  (!!this code can be modified, may be replaced with "JP (IY)")
      XOR (HL)
      LD (DE),A
      INC HL
      INC E
$CB25 LD A,(DE)   ;handle fourth byte (!!this code can be modified, may be replaced with "JP (IY)")
      XOR (HL)
      LD (DE),A
      INC HL
$CB29 LD A,(DE)   ;handle fifth byte  (!!this code can be modified, may be replaced with "JP (IY)")
      XOR (HL)
$CB2B NOP         ; modified code
      INC HL
      INC HL
      INC HL
      LD E,C      ;to the left
      INC D       ;to next line
;second line of 5 bytes, same as above
$CB31 LD A,(DE)
      XOR (HL)
      LD (DE), A
      INC HL
      INC E
      LD A, (DE)
      XOR (HL)
      LD (DE), A
      INC HL
      INC E
      LD A, (DE)
      XOR (HL)
      LD (DE), A
      INC HL
      INC E
      LD A, (DE)
      XOR (HL)
      LD (DE), A
      INC HL
      LD A, (DE)
      XOR (HL)
$CB46 NOP         ; modified code
      INC HL
      INC HL
      INC HL
      LD E,C
      INC D
      LD A,D
      AND $07
$CB4F JP NZ,$CB5C
      LD A,E
      ADD A,$20
      LD E,A
      CCF
      SBC A,A
      AND $F8
      ADD A,D
      LD D,A        ;DE has re-calculated video-mem addr
$CB5C DJNZ $CB15    ;loop

$CB5E LD SP,??      ;location of code to patch (value examples: $CB2B, $CB1D)
      LD BC,$AE1A   ;machine codes for "LD A,(DE); XOR (HL)"
      PUSH BC       ;patch the code
$CB65 LD SP,??      ;another location to patch (value examples: $CB46, $CB38)
      PUSH BC       ;patch it!
$CB69 LD IY,??      ;modified code, return address (CECA)
$CB6D JP (IY)       ;return
--------------

--------------
Variables:

$CC7A (1) - number of currently drawn row (8-pixel wide)
$CC7B (1) - ??
$CC7C (1) - argument for $CCA3, attribute
$CC7D (1) - ?
$CC7E (1) - variable for $CA2F, height of a sprite in line-pairs
$CC7F (2) - argument for $CCA3, (internal variable for $CA2F), video mem address
$CC81 (?) - pointer to current dynamic drawn object

$CC83 - table for code modification of procedure $CA2F.
        Contains 4 entries, 8-byte each

--------------
$CCA3: Draw a (3*1) sprite - $CD12 (+2)

Input: HL - address of a sprite
       DE - video memory addr
       ($CC7C) - attribute
       ($CC7F) - same as DE

Sprite height is 8 pixels, width is 8*3 = 24 pixels


$CCA3 LD BC, $021E  ;B - height, С - how much bytes to skip to 
                    ;to get to next row 
                    ;(whole row $20) - (length $03) + $01 = $1E
$CCA6 LD A,($CC7C)  ;attribute
$CCA9 LD ($CCBD),A  ;modify a code, so we use this attribute

;calculate address in attribute area and amount of columns and rows
$CCAC LD A,D
$CCAD AND 07        ;live 3 lower bits (remainder of dividing by 8)
$CCAF JP NZ,$CCB3   ;
$CCB2 DEC B         ;if they are 0, then one row less
$CCB3 LD A,D
      RRCA
      RRCA
      RRCA          ;divide by 8
      AND 03
      OR $58
      LD D,A        ;now DE points to attribute area

;loop to put color attributes
$CCBC LD A,$41      ;attr value (this code is modified! above)
      LD (DE),A     
      INC E
      LD (DE),A
      INC E
      LD (DE),A     ;draw 3 attrib cells in row
$CCC3 LD A,E
      ADD A,C
      LD E,A
      LD A,00
      ADC A,D
$CCC9 LD D,A        ;move to next row
$CCCA DJNZ $CCBC    ;loop to color next row
;end of loop

;draw a sprite
;HL=sprite addres
$CCCC LD DE,($CC7F) ;restore video mem address from arguments
      LD A,D
      EX AF,AF'     ;store D
      LD A,D
      CPL
      AND $07
      INC A         ;how many pixel rows till 'break'
      RRCA          ;divided by 2
;loop to draw upper part of sprite
$CCD9 LD B,E        ;store E
      LDI
      LDI
      LDI           ;move 3 bytes from sprite (HL) to video memory (DE)
      INC D         ;to next line
      LD E,B        ;restore E, moving to the left side of output location
      LDI
      LDI
      LDI           ;again 3 bytes
      INC D         ;to next line
      LD E,B        ;restore E, moving to the left side of output location
      DEC A         ;decrement the counter
      JP NZ, $CCD9  ;next loop

$CCED LD A,E
      ADD A,$20
      LD E,A  
      CCF
      SBC A,A
      AND $F8
      ADD A,D       
      LD D,A        ;moving to pixel row after the break
      LD B,E        ;save E
      EX AF,AF'     ;restore D
      AND $07       ;keep lower 3 bits
      JR Z,$CD12    ;if they are 0, then we are done
      RRCA          ;otherwise, we need to drow second part
;second loop, remaining of the sprite
$CCFE LDI
      LDI
      LDI           ;move 3 bytes from sprite (HL) to videomem (DE)
      INC D         ;next pixel row
      LD E,B        ;restore E, moving to the left side of output location
      LDI
      LDI
      LDI           
      INC D         
      LD E,B        ;again
      DEC A         ;decrement counter
$CD0F JP NZ $CCFE   ;to the beginning of the loop
;end of loop
$CD12 JP $C9FA      ;return

--------------
$CD15: Draw a sprite, width = 4 bytes - $CE77 (+1)

Input: HL - address of a sprite
       DE - video memory addr
       ($CC7C) - attribute
       ($CC7F) - same as DE
       height of a sprite is controlled by modifying a code at locations $CD17, $CD95,
       IY - return addr

$CD15 LD BC,??      ;this code is modified before the call, B - height of sprite, in 8-pixel units
      LD A,($CC7C)  ;attribute
      BIT 7,A       ;check high bit
      JP Z,$CD38
      XOR A
      LD ($CD53),A  ;modify the code - don't draw last attrib
      LD A,($CC7C)
      AND $7F       ;clear high bit
      LD IY,$CD30   ;change return addr
      JP $CD38      ;draw the sprite
$CD30 LD A,$12      ;will return here
      LD ($CD53),A  ;restore modified code
      JP $C9FA      ;and return from the proc

;part 1: colour video attribs
$CD38 LD ($CD4C),A  ;modify the code: attrib value
      LD A,D
      AND 7         ;check if sprite's upper border exactly matches 8-line row border
      JP NZ,$CD42   
      DEC B         ;if matches, decrement height by 1
$CD42 LD A,D
      RRCA
      RRCA
      RRCA
      AND 3
      OR 58
      LD D,A        ;in DE there is a calculated attrib area address
;attrib colouring loop, by rows containing 4 attrib blocks each
$CD4B LD A,???      ;attrib value - modified code, see above
      LD (DE),A     ;write first attrib
      INC E
      LD (DE),A     ;second
      INC E
      LD (DE),A     ;third
      INC E
$CD53 LD (DE),A     ;this command may be overwritten with NOP, if last attrib should not be drawn
      LD A,E
      ADD A,$1D
      LD A,E
      ADD A,$1D
      LD E,A
      LD A,C
      ADC A,D
      LD D,A        ;DE contains attrib area addr for next row
      DJNZ $CD4B    ;loop, colour next attrib row

      LD DE,($CC7F) ;restore video-mem address
      LD SP,HL      ;will use stack as source

      LD A,D
      EX AF,AF'     ;store

;part 2: draw top slice of a sprite, by line-pairs. Number of line-pairs is in reg B
      LD A,D
      CPL
      AND 7
      INC A
      RRCA
      LD B,A        ;how many line-pairs in top slice
      LD C,E        ;store low part of video-mem addr
;loop
;draw one line of sprite, 4 bytes wide
$CD6C POP HL        ;read two bytes of sprite
      LD A,(DE)     ;read video mem byte
      XOR L         ;combine using xor
      LD (DE),A     ;write back to video mem
      INC E         ;move to next video mem byte
      LD A,(DE)     ;read it
      XOR H         ;combine using xor
      LD (DE),A     ;write back
      INC E         ;to next video mem byte
      POP HL        ;the same story, another 2 bytes of sprite
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E    
      LD A,(DE)
      XOR H
      LD (DE),A    
      INC D         ;to next line
      LD E,C        ;to the left
;draw second line of sprite, 4 bytes wide, the same as above
$CD7F POP HL        
      LD A,(DE)     
      XOR L
      LD (DE),A     
      INC E         
      LD A,(DE)
      XOR H
      LD (DE),A     
      INC E
      POP HL        
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E    
      LD A,(DE)
      XOR H
      LD (DE),A    
      INC D         
      LD E,C
$CD92 DJNZ $CD6C   ;decrement counter of line-pairs in B, and loop until slice will be drawn
;end of part 2

;part 3: draw sprite by 8-line slices

$CD94 LD B,???     ;how many slices - code is modified
;loop of drawing the sprite by 8-line slices
;now we are at the last line of 8-line row, need to move to next line
$CD96 LD A,E
      ADD A,$20
      LD E,A
      CCF
      AND $F8
      ADD A,D
      LD D,A       ;moved to next line
$CDA0 LD C,E       ;store low byte, so we could return to the left byte of video-mem
;draw one line of sprite, 4 bytes wide
$CDA1 POP HL        ;read two bytes of sprite
      LD A,(DE)     ;read video mem byte
      XOR L         ;combine using xor
      LD (DE),A     ;write back to video mem
      INC E         ;move to next video mem byte
      LD A,(DE)     ;read it
      XOR H         ;combine using xor
      LD (DE),A     ;write back
      INC E         ;to next video mem byte
      POP HL        ;the same story, another 2 bytes of sprite
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E
      LD A,(DE)
      XOR H
      LD (DE),A
      INC D         ;to next line
      LD E,C        ;to the left
;draw second line of sprite, 4 bytes wide, the same as above
$CDB4 POP HL
      .........
;draw third line of sprite, 4 bytes wide, the same as above
$CDC7 POP HL
      .........
;draw fourth line of sprite, 4 bytes wide, the same as above
$CDDA POP HL
      .........
;draw fifth line of sprite, 4 bytes wide, the same as above
$CDED POP HL
      .........
;draw sixth line of sprite, 4 bytes wide, the same as above
$CE00 POP HL
      .........
;draw seventh line of sprite, 4 bytes wide, the same as above
$CE13 POP HL
      .........
;draw eighth line of sprite, 4 bytes wide, the same as above
$CE26 POP HL
      .........
$CE39 DEC B        ;decrement slice counter
      DJNZ $CD96   ;loop to next full slice

$CE3D LD A,E
      ADD A,$20
      LD E,A
      CCF
      SBC A,A
      AND $F8
      ADD A,D
      LD D,A       ;to next line
;end of part 3

;part 4: optionally draw lowest, partly filled slice
      EX AF,AF'    ;restore
      AND 07
      JR Z,$CE77   ;if aligned, then nothing to draw
      RRCA
      LD B,A       ;otherwise reg B has number of line-pairs to draw
;loop
;draw one line of sprite, 4 bytes wide
$CE4F POP HL
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E
      LD A,(DE)
      XOR H
      LD (DE),A
      INC E
      POP HL
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E
      LD A,(DE)
      XOR H
      LD (DE),A
      INC D        ;to next line
      LD E,C       ;to the left
;draw second line of sprite, 4 bytes wide, the same as above
      POP HL
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E
      LD A,(DE)
      XOR H
      LD (DE),A
      INC E
      POP HL
      LD A,(DE)
      XOR L
      LD (DE),A
      INC E
      LD A,(DE)
      XOR H
      LD (DE),A
      INC D
      LD E,C
      DJNZ $CE4    ;decrement counter of line-pairs in B, and loop until slice will be drawn
;end of part 4
$CE77 JP (IY)      ;return

--------------
$CE8F: Draw a normal platform - $CEA8 (+2)

$CE8F LD A,3
      LD ($CD17),A  ;modify the code of proc $CD15: height of a platform in 8-pixel units
      LD A,1
      LD ($CD95),A  ;modify the code of proc $CD15: how many full 8-line slices in sprite
      LD IY,$CEA0   ;return addr
      JP $CD15      ;call sprite-draw proc
$CEA0 LD HL,$CD17   ;will return here
      INC (HL)      ;modify (?restore?) the code of proc $CD15: height of a object in 8-pixel units
      LD HL,$CD95
      INC (HL)      ;modify (?restore?) the code of proc $CD15: height of a object in 8-pixel units
$CEA8 JP $C9FA      ;return

--------------
$CED2: Draw a partly-visible platform at the top of the screen - $CED9 (+2)

$CED2 LD B,A
      RRCA          ; div by 2
      LD ($CC7E),A
      LD A,$10
$CED9 JP $CA6D

--------------
$CEDC: ???

$CEDC CALL $C517    ;calculate player's sprite address
      LD HL,$C439   ;dynamic drawn object table base address
      LD ($CC81),HL ;store here

;part #1, go through all visible objects, put their vertical coordinates divided by 8 at addresses starting from $D169
      EXX
      LD HL,$D169   ;?? some location
      LD BC,$0CFF   ;reg B is a loop counter, reg C is an end marker
      EXX
      LD HL,$C3A9   ;list of visible colliding objects, starting from player's object info
      LD DE,$0C     ;struct size
      LD B,$18      ;mask value, bits 3 and 4
;loop
$CEF5 LD A,(HL)     ;read first byte of source struct, example value: $50
      AND A
      JR Z,$CF1B    ;go if 0
      LD C,$01      ;default value for reg C
      AND B         ;apply mask
      CP B          ;check if both bits are on
      JP NZ,$CF02
      LD C,$03      ;if they are, this will be the value in reg C
$CF02 RRCA
      RRCA
      RRCA          ;rotate right, so bits 3 and 4 become bits 0 and 1
      ADD A,C       ;add constant
      LD C,A        ;store here
      INC HL
      LD A,(HL)     ;read second byte - vertical coordinate
      DEC HL        ;HL points back to beginning of a struct
      RRCA
      RRA
      SRL A         ;reg A = reg A / 8
      ADD A,C       ;add
      ADD HL,DE     ;to next struct
      EXX           ;switch to destination addresses
      LD (HL),A     ;write into destination location
      INC HL        ;increment
      DEC B         ;decrement loop counter
      EXX
      JP NZ,$CEF5   ;loop
$CF18 JP $CF24      ;end of loop, continue execution from $CF24
$CF1B ADD HL,DE     ;to next source struct
      EXX
      LD (HL),C     ;write $FF marker
      INC HL        ;to next result addr
      DEC B         ;decrement loop counter
      EXX
      JP NZ,$CEF5   ;loop

;part #2, find items with minimal vertical coord / 8 at addr $D175
$CF24 LD HL,$D174   ;this address points to the last value stored in previous loop ($D169 + $0C - $01)
      LD A,$18      ;initial value to compare with
      LD B,$0C      ;loop counter initial value
;loop in backward direction
$CF2B CP (HL)       ;compare row number with current min value
      JR NC,$CF34   ;(HL) is less or equal, go there, otherwise, (HL) has $FF marker
      DEC HL        ;just skip this entry
      DJNZ $CF2B    ;loop
      JP $CF49      ;if loop has finished, go further
$CF34 JR Z,$CF42    ;if (HL) is equal to current min value, go there
;we found item which vertical coord is less then prev mininum. Store it, and keep the loop comparing this new value
      LD DE,$D175   ;start of list of minimal items
      LD A,B
      LD (DE),A     ;store current item index (loop counter value) here
      LD A,(HL)     ;read vertical coord of current item, it will be next value to compare against
      DEC HL
      DJNZ $CF2B    ;loop
      JP $CF49      ;if loop has finished, go further
;we found an item which vertical coord is equal to prev minimum. Store it after prev minumum value
$CF42 INC DE        ;since reg DE points to last item which coord is equal to minimal, then move to next
      LD A,B
      LD (DE),A     ;store item index (loop counter value)
      LD A,(HL)     ;read vertical coord of current item, it will be next value to compare against
      DEC HL
      DJNZ $CF2B
;end of loop
$CF49 CP $18        ;check if minimal coord has not changed in prev loop
      RET Z         ;and exit in this case
      LD ($D182),A  ;put minimal coord ?? here
      XOR A
      INC DE
      LD (DE),A     ;write 0 after the list of items wiith minimal coords

      LD D,A        ;reg D will be 0
      LD BC,$D175   ;start of list of minimal items
$CF56 LD A,(BC)     ;load item index
      AND A         ;check if 0 (end of list marker)
      JR Z,$CF65    ;go out if end of list
      LD HL,$D168   ;?? some location - it's a just before a start of first list: $D169 - $01
      INC BC        ;move to next item
      LD E,A        ;move item index into reg E, so DE makes offset
      ADD HL,DE     ;add to base address
      LD (HL),$FF   ;write this value
$CF62 JP $CF56      ;loop

$CF65 LD HL,$D135
      LD ($D131),HL
      LD HL,$D14F
      LD ($D133),HL
CF71: LD BC,$D175
CF74: LD A,(BC)
CF75: AND A
CF76: JR Z,$CFA5
CF78: ADD A, A
CF79: ADD A, A
CF7A: LD E, A
CF7B: ADD A, A
CF7C: ADD A, E
CF7D: LD E, A
CF7E: LD D, $00
CF80: LD HL, $C39D
CF83: ADD HL, DE
CF84: INC BC
CF85: LD A, (HL)
CF86: EX DE, HL
CF87: AND $18
CF89: JR Z, $CF98
CF8B: LD HL, ($D133)
CF8E: LD (HL), E
CF8F: INC HL
CF90: LD (HL), D
CF91: INC HL
CF92: LD ($D133), HL
CF95: JP $CF74
CF98: LD HL, ($D131)
CF9B: LD (HL), E
CF9C: INC HL
CF9D: LD (HL), D
CF9E: INC HL
CF9F: LD ($D131), HL
CFA2: JP $CF74
CFA5: LD HL, $D135
CFA8: CALL $CFB5
CFAB: LD HL, $D14F
CFAE: CALL $CFB5
CFB1: JP $CF24


--------------
;$CFB5 - ??

Params: HL

$CFB5 LD B,$00
      LD E,(HL)     ;read low byte into reg E
      LD (HL),B     ;overwrite with 0
      INC HL
      LD A,(HL)     ;get high byte
      AND A
      RET Z         ;exit if 0
      LD (HL),B     ;otherwise overwrite with 0
      INC HL
      PUSH HL       ;save
      LD D,A        ;copy high byte into reg D, so DE has full address
      LD A,(DE)     ;read first byte (status byte)
      AND $18       ;mask
      LD C,A        ;copy here, makes BC an offset
      LD HL,$D0F1   ;base address
      ADD HL,BC     ;add offset
      INC DE
      LD A,(DE)     ;read second byte (vertical coord)
      CP (HL)       ;compare with location at HL
      INC HL
      JR C,$CFE6    ;go if less
      CP (HL)       ;compare with second byte
      INC HL
      JR NC,$CFE7   ;go if greater or equal
      INC DE
      LD A,(DE)     ;load third byte
      CP (HL)
      INC HL
      JR C,$D004    ;go if less
      CP (HL)
      INC HL
      JR NC,$D005
      SRL C
      LD HL,$D0DB
      ADD HL,BC
      JP $D017

CFE6: INC HL
CFE7: INC HL
CFE8: INC HL
CFE9: CP (HL)
CFEA: JR C, $CFF5
CFEC: INC HL
CFED: CP (HL)
CFEE: INC HL
CFEF: JR NC, $CFB4
CFF1: INC DE
CFF2: JP $D007

CFF5: LD A, $FA
CFF7: CP (HL)
CFF8: JR NZ, $CFB4
CFFA: INC HL
CFFB: LD A,(DE)     ;reload vertical coord
CFFC: CP (HL)
CFFD: JR NC, $CFB4
CFFF: INC HL
D000: INC DE
D001: JP $D007

D004: INC HL
D005: INC HL
D006: INC HL

$D007 LD A,(DE)     ;load horizontal coord
D008: CP (HL)
D009: INC HL
D00A: JR C, $CFB4
D00C: CP (HL)
D00D: JR NC, $CFB4
D00F: SRL C
D011: LD HL, $D0DB
D014: ADD HL, BC
D015: INC HL
D016: INC HL

D017: LD A, (HL)
D018: INC HL
D019: LD H, (HL)
D01A: LD L, A
D01B: PUSH HL
D01C: DEC DE
D01D: DEC DE
D01E: LD ($D06A), SP
D022: LD A, (DE)
D023: BIT 7, A
D025: JP NZ, $D0B7
D028: CP $50
D02A: JP Z, $D0B1
D02D: LD H, B
D02E: LD L, C
D02F: LD SP, $D111
D032: ADD HL, SP
D033: LD SP, HL
D034: POP IX
D036: POP BC
D037: LD A, (DE)
D038: LD H, B
D039: LD L, B
D03A: AND $07
D03C: JR Z, $D043
D03E: ADD HL, BC
D03F: DEC A
D040: JP NZ, $D03E
D043: ADD HL, HL
D044: ADD HL, HL
D045: LD A, (DE)
D046: INC DE
D047: INC DE
D048: BIT 3, A
D04A: JR NZ, $D057
D04C: ADD HL, HL
D04D: INC DE
D04E: LD A, (DE)
D04F: DEC DE
D050: RRCA
D051: JR NC, $D057
D053: ADD HL, BC
D054: ADD HL, BC
D055: ADD HL, BC
D056: ADD HL, BC
D057: LD A, (DE)
D058: AND $07
D05A: RR A
D05C: JR Z, $D063
D05E: ADD HL, BC
D05F: DEC A
D060: JP NZ, $D05E
D063: LD SP, IX
D065: ADD HL, SP
D066: DEC DE
D067: DEC DE
D068: EX DE, HL
D069: LD SP, $FFF8
D06C: PUSH HL
D06D: POP IY
D06F: LD HL, ($CC81)
D072: LD A, ($D182)
D075: LD (HL), A
D076: INC HL
D077: LD B, D
D078: LD C, E
D079: LD E, (IY+$01)
D07C: LD A, E
D07D: AND $C0
D07F: RRA
D080: SCF
D081: RRA
D082: RRCA
D083: XOR E
D084: AND $F8
D086: XOR E
D087: LD D, A
D088: LD A, (IY+$02)
D08B: RLCA
D08C: RLCA
D08D: RLCA
D08E: XOR E
D08F: AND $C7
D091: XOR E
D092: RLCA
D093: RLCA
D094: LD (HL), A
D095: INC HL
D096: LD (HL), D
D097: INC HL
D098: LD (HL), C
D099: INC HL
D09A: LD (HL), B
D09B: INC HL
D09C: LD D, (IY+$01)
D09F: LD (HL), D
D0A0: INC HL
D0A1: LD E, (IY+$06)
D0A4: LD (HL), E
D0A5: INC HL
D0A6: POP DE
D0A7: LD (HL), E
D0A8: INC HL
D0A9: LD (HL), D
D0AA: INC HL
D0AB: LD ($CC81), HL
D0AE: JP $CFB4
D0B1: LD HL, ($C4D8)
D0B4: JP $D068
D0B7: LD ($D0D6), DE
D0BB: LD SP, $D121
D0BE: LD H, B
D0BF: LD L, C
D0C0: ADD HL, SP
D0C1: LD SP, HL
D0C2: LD HL, $D0E9
D0C5: LD A, (DE)
D0C6: AND $07
D0C8: LD C, A
D0C9: ADD HL, BC
D0CA: LD A, (HL)
D0CB: POP BC
D0CC: POP DE
D0CD: LD H, D
D0CE: LD L, D
D0CF: ADD HL, DE
D0D0: DEC A
D0D1: JP NZ, $D0CF
D0D4: ADD HL, BC
D0D5: LD DE, $C3CD
D0D8: JP $D068
D0DB: AND E
D0DC: CALL Z, $CB6F
D0DF: ADC A, A
D0E0: ADC A, $AB
D0E2: ADC A, $15
D0E4: CALL $CA2F
D0E7: LD A, C
D0E8: ADC A, $01
D0EA: LD BC, $0202
D0ED: INC BC
D0EE: INC BC
D0EF: INC B
D0F0: INC B
D0F1: DJNZ $D07D
D0F3: JR $D0C5

--------------

$D169

<======================================>

------------------------
$D183: Draw a full-width level block -  $D241 (+1)

IY - return address

HL - address of horizontally shifted sprite block
DE - address in video mem

Alternate regs:
HL - address in attrib area
DE - pair for attrib values (D - for top, E - for low part of block)
BC - $20

The block is drawn by horizontal slices (up to 3 slices).
For each slice first the pixels, then attribs. Pixels are drawn horizontally from left to right, in two passes.
Leftmost byte is composed with video memory using OR (so not to overwrite block to the left), others just written
to video memory.
This code is modified before calling it:
      number of lines in each slice is set
      "return" command JP (IY) is placed if less than 3 slices should be drawn


$D181 LD SP,HL     ;stack points to sprite source
      EX DE,HL     ;HL - now points to video mem pixel area addr

;draw a top slice
$D185 LD B,??      ;number of line pairs to draw (max 4).
                   ;this value is modified before calling this procedure at location $D186
;draw a horizontal slice of block, height in reg B (up to 4 line-pairs)
$D188 LD C,L       ;save low byte of video mem addr
;now we move one line (6 bytes) of shifted sprite for block in video memory
$D194 POP DE       ;takes two bytes from stack
      LD A,E       
      OR (HL)
      LD (HL),A    ;use OR to draw sprite byte on video memory
      INC L        ;next video memory byte
      LD (HL),D    ;just put the sprite byte here
      INC L        ;next video mem address
      POP DE       ;take next two bytes
      LD (HL),E
      INC L
      LD (HL),D
      INC L        ;put them in video-mem
      POP DE       ;another two bytes
      LD (HL),E    ;
      INC L        ;
      LD (HL),D    ;put them in video-mem
      LD L,C       ;restore video mem address
$D199 INC H        ;on next line in video memory
      POP DE       ;same code again, another 6-byte line of sprite
      ....
$D1AB INC H
$D1AC DJNZ $D188   ;loop
;now color attribs for a slice
$D1AE EXX
      LD ($D1BD),SP;remember the point in sprite where we stopped drawing (modify the code below)
      LD SP,HL     ;address in attrib area
      LD A,E       ;save attribs for next line
      LD E,D       ;D and E contain the same values
      PUSH DE      ;set in memory 3 times, so total 6 attrib bytes
      PUSH DE
      PUSH DE
      ADD HL,BC    ;to next line
      LD D,A
      LD E,A       ;attribs for next block slice
$D1BC LD SP,???    ;SP again points to sprite source where we stopped previously (this code is modified, see above)
      EXX          ;save regs
;end of slice drawing

$D1C0 JP (IY) ? LD A,L     ;this code is modified: either return or draw second slice
;the code to draw a second slice, the same as for a first slice
      .....
$D1CB LD B,???     ;how many line-pairs in second slice (this code is modified at $D1СС)
      ....
$D201 JP (IY) ? LD A,L    ;this code is modified: either return or draw a third slice
;the code to draw a third slice, the same as for a first slice
      .....
$D20C LD B,??      ;how many line-pairs in third slice
      .....
$D241 JP (IY)      ;return finally

------------------------
$D243: Draw leftmost block. It is partially visible - $D300 (+1)

IY - return address

HL - address of horizontally shifted sprite block
DE - address in video mem

Alternate regs:
HL - address in attrib area
DE - pair for attrib values (D - for top, E - for low part of block)
BC - $20

Very similar to $D183.

The block is drawn by horizontal slices (up to 3 slices).
For each slice first the pixels, then attribs.
This code is modified before calling it:
   number of lines in each slice is set
   and "return" command JP (IY) is placed if less than 3 slices should be drawn
   number of horizontal bytes in sprite to skip is set
   and target of JP command is modified to control width of block


$D243 LD A,($D27C) ;this is not a variable, this is a modified value in code below
      INC A
      JP Z,$D300   ;don't draw
$D24A LD SP,??     ;this value is modified before calling: how many horizontal parts of sprite are not visible? (0-5)

;first slice
;draw visible part of block
      ADD HL,SP    ;skip some first parts of sprite
$D24E LD B,$??     ;how many horizontal line-pairs to draw (this code is modified)
      LD C,$??     ;this code is modified
;loop to draw pixels
      LD A,E       ;save low byte of video mem addr
$D253 JP ??        ;($D256 - $D260) this value is modified before calling, it controls how much of sprite to draw
$D256 LDI
$D258 LDI
$D25A LDI
$D25C LDI
$D25E LDI
$D260 LDI          ;copy up to 6 bytes of sprite into video memory
$D262 LD E,A       ;restore low byte of video mem
      ADD HL,SP    ;skip some parts of a sprite
      INC D        ;next line in video mem
$D265 JP ??        ;($D268 - $D272) this value is modified before calling, it controls how much of sprite to draw
$D268 LDI
$D26A LDI
$D26C LDI
$D26E LDI
$D270 LDI
$D272 LDI          ;copy up to 6 bytes of sprite into video memory
$D274 LD E,A
      ADD HL,SP
      INC D
      DJNZ $D252   ;loop
;draw attributes
      EXX
      LD A,E       ;save
$D27B LD E,??      ;($01 - $06) how many attribs to draw, width. This value is set outside before calling
$D27D LD C,$1C     ;offset of attrib at next block slice, reg C = $20 - reg E. This value is set outside before calling
      LD B,E
;loop
$D280 LD (HL),D    ;put attrib value
      INC L
      DJNZ $D280   ;loop
      LD D,A       ;restore
      ADD HL,BC    ;add offset
      EXX
;end of attribs drawing
;end of first slice

;second slice
;draw visible part of block
$D287 LD A,E
      JP (IY) ? ADD A,$20     ;this code is modified: either return or draw next slice
      LD E,A
      CCF
      SBC A,A
      AND $F8
      ADD A,D
      LD D,A
$D291 LD B,$??     ;how many horizontal line-pairs to draw, this code is modified before calling it
$D293 LD C,$FF
;loop to draw pixels
      LD A,E       ;save low byte of video mem addr
$D296 JP ??        ;($D299 - $D2A3) this value is modified before calling, it controls how much of sprite to draw
$D299 LDI
$D29B LDI
$D29D LDI
$D29F LDI
$D2A1 LDI
$D2A3 LDI
$D2A5 LD E,A       ;restore low byte of video mem addr
      ADD HL,SP    ;skip some first parts of sprite
      INC D        ;next line in video mem
$D2A8 JP $D2AF     ;($D2AB - $D2B5) this value is modified before calling, it controls how much of sprite to draw
$D2AB LDI
$D2AD LDI
$D2AF LDI
$D2B1 LDI
$D2B3 LDI
$D2B5 LDI
$D2B7 LD E,A       ;restore low byte of video mem addr
      ADD HL,SP    ;skip some first parts of sprite
      INC D        ;next line in video mem
      DJNZ $D295   ;loop
;draw attributes
      EXX
      LD B,E
$D2BE LD (HL),D
      INC L
      DJNZ $D2BE   ;loop
      ADD HL,BC    ;shift to next row
      EXX
;end of attribute drawing

;third slice
$D2C4 LD A, E
      JP (IY) ? ADD A,$20   ;this code is modified: either return or draw next slice
      LD E, A
      CCF
      SBC A, A
      AND $F8
      ADD A, D
      LD D, A
      LD B, $02
      LD C, $FF
      LD A, E
$D2D3 JP $D2DA
$D2D6 LDI
$D2D8 LDI
$D2DA LDI
$D2DC LDI
$D2DE LDI
$D2E0 LDI
$D2E2 LD E, A
      ADD HL, SP
      INC D
$D2E5 JP $D2EC
$D2E8 LDI
$D2EA LDI
$D2EC LDI
$D2EE LDI
$D2F0 LDI
$D2F2 LDI
$D2F4 LD E, A
      ADD HL, SP
      INC D
$D2F7 DJNZ $D2D2
$D2F9 EXX
$D2FA LD B, E
$D2FB LD (HL), D
$D2FC INC L
$D2FD DJNZ $D2FB
$D2FF EXX
$D300 JP (IY)      ;return, end of third slice

------------------------  
$D302: Draw rightmost block. It is partially visible - $D3СС (+1)

IY - return address

HL - address of horizontally shifted sprite block
DE - address in video mem

Alternate regs:
HL - address in attrib area
DE - pair for attrib values (D - for top, E - for low part of block)
BC - $20

Very similar to $D183.

The block is drawn by horizontal slices (up to 3 slices).
For each slice first the pixels, then attribs.
This code is modified before calling it:
   number of lines in each slice is set
   and "return" command JP (IY) is placed if less than 3 slices should be drawn
   number of horizontal bytes in sprite to skip is set
   and target of JP command is modified to control width of block


$D302 LD SP,??      ;(0 - 5) how many bytes of block's sprite in each line to skip, this code is modified
      LD B,??       ;(0 - 4) how many line pairs in first slice, this code is modified
      LD C,$FF

;first slice
$D309 LD A,(DE)     ;take first byte from video memory
      OR (HL)       ;compose with sprite's byte using OR
      LD (DE),A     ;write back to video memory
      LD A,E        ;store low byte of video mem addr
      INC E
      INC HL
$D30F JP ?$D31C...$D312?  ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
$D312 LDI
      LDI
      LDI
      LDI
      LDI
$D31C LD E,A       ;restore low byte of video mem addr
      ADD HL,SP    ;skip some parts of sprite
      INC D        ;move to next line in video mem
      LD A,(DE)    ;now goes similar code, draw one more line
      OR (HL)
      LD (DE),A    
      INC E
      INC HL
$D325 JP ?$D332...$D328? ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
$D328 LDI
      LDI
      LDI
      LDI
      LDI
$D332 LD A,E       ;restore low byte of video mem addr
      ADD HL,SP    ;skip some parts of sprite
      INC D        ;to next line
      DJNZ $D309   ;repeat for next pair of lines

;draw attributes
$D337 EXX
      LD A,E
$D339 LD E,???     ;this code is modified: now many squares to color horizontally
      LD C,???     ;this code is modified: now many squares to move through to get to location on next line
      LD B,E
;coloring loop
$D33E LD (HL),D    ;write attrib
      INC L        ;move to next (to the right)
      DJNZ $D33E   ;in loop
      LD D,A
      ADD HL,BC    ;to next line
      EXX
      LD A,E
$D346 JP (IY) ? ADD A,$20  ;this code is modified: either return or go for next slice
;end of first slice

      LD E,A
      CCF
      SBC A,A
      AND $F8
      ADD A,D
      LD D,A       ;next line in video mem
$D34F LD B,??      ;how many line pairs in next slice: this code is modified outside
      LD C,$FF
;very similar code as for first slice
$D353 LD A,(DE)
      ......
$D359 JP ?$D35E?   ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
      ......
$D36F JP ?$D374?   ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
      ......
$D385 DJNZ $D353   ;loop
      ......
$D38A JP (IY) ?    ;this code is modified: either return or go for next slice
;third slice
$D39D JP ?$D3A2?   ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
      ......
$D3B3 JP ?$D3B8?   ;this code is modified. It controls, how much of sprite is drawn horizontally, skipping some LDIs
      .....
$D3CC JP (IY)      ;return

------------------------

$D3CE: Clear a video memory slice, 16 lines $D427 (+1)

HL - start address
IY - return address

;clears row of 8 lines
$D3CE LD B,4       ;number of line-pairs to fill
      LD DE,0      ;fill memory with this value (0)
;loop
$D3D3 LD SP,HL     ;set stack to the addr
      LD (HL),E    ;just in case
      PUSH DE      ;write into memory
      PUSH DE
      .....
$D3E0 PUSH DE      ;altogether 12 PUSH-es, so 24 bytes will be written
      INC H        ;to next line
      LD SP,HL     ;set stack to the addr
      LD (HL),E    ;just in case
      PUSH DE      ;write into memory
      ........
$D3EF PUSH DE      ;again 12 PUSH-es
      INC H        ;to next video-line
      DJNZ $D3D3   ;repeat the loop

$D3F3 LD A,H
      SUB $08
      LD H,A
      LD A,L
      ADD A,$20
      LD L,A      ;move to the next 8-line row

;the same as previous, clear another 8-line row
$D3FB LD B,4
$D3FD LD SP,HL
      ....
$D41B DJNZ $D3FD
;end of loop

$D41D LD A,L
      ADD A,$20
      LD L,A
      CCF
      SBC A,A
      AND $F8
      ADD A,H
      LD H,A    ;?
$D427 JP (IY)   ;return

------------------------
$D429: Table of addresses of shifted sprite sets
       4 shifts (0, 2, 4, and 6 pixels) and two bytes for each address


------------------------
$D431 - Draw dynamic game screen - $D902
This procedure is really big, and it heavily uses code modification.
It consists of 4 main parts:
  * Preparation
  * Draw upper, partly visible row of blocks
  * Draw middle, fully visible blocks
  * Draw bottom, partly visible row of blocks

$D431 LD ($DB90),SP  ;save stack pointer here, since will use stack operations as fast mem writing
      LD A,3         ;row to start from
      LD ($CC7A),A   ;init
      LD HL,$C439    ;dynamic drawn object info table base
      LD ($CC81),HL  ;store here
      LD HL,($C4E8)  ;coordinates (horizontal, vertical) in labyrinth blocks of upper left visible block
      LD DE,0        ;additional coordinates are 0
      CALL $C8CD     ;calculate address of upper left visible block
      PUSH HL
      POP IX         ;into IX
      LD A,($C4EA)   ;horizontal shift of block to the right
      ADD A,A        ;*2
      LD L,A
      LD H,0         ;into HL, will be offset
      LD BC,$D429    ;base of table with shifted sprites locations
      ADD HL,BC      ;add sprite shift as an offset in table. HL points to table entry
      LD SP,HL       ;will use stack to read from memory
      POP HL         ;HL points to base address of shifted sprite-set
      LD ($DB8E),HL  ;save

;based on horizontal coordinate modify the code of drawing procedures

      LD B,1
      LD A,($C4EA)   ;horizontal shift of block to the right in pair of pixels
      AND A
      LD A,($C4EC)   ;horizontal shift of block in bytes
      JP NZ,$D489    ;jump if ($C4EA) != 0, and we have B = 1
      DEC B          ;B = 0
      AND A
      JP NZ,$D489    ;jump if  ($C4EC) != 0, and we have B = 0

;if ($C4EA) == 0 and ($C4EC) == 0, so no horizontal shift at all
      LD A,05        ;then leftmost and rightmost blocks have width 5
      LD ($D33A),A   ;modify the code: how many colour attribs wide is rightmost block
      LD ($D24B),A   ;modify the code: how many colour attribs to skip in leftmost block
      LD A,$1B       ;how many bytes to add to get on next attrib line
      LD ($D33C),A   ;modify the code
      LD A,$FF       ;how many bytes to add to get to next pixel line
      LD ($D24C),A   ;modify the code
      NEG            ;A=1
      LD ($D303),A   ;how many bytes of rightmost block to skip
      DEC IX         ;
$D486 JP $D4AC       ;go to draw

;if either ($C4EA) != 0 or ($C4EC) != 0, so there is a horizontal shift
;reg A contains value from ($C4EC)
$D489 ADD A,B        ;if there is a pixel-shift, then increment visible attribs on 1
      LD ($D24B), A  ;modify the code: how many colour attribs to skip in leftmost block
      LD ($D33A), A  ;modify the code: how many colour attribs wide is rightmost block
      LD B,A         ;save A into B
      SUB $20
      NEG            ;A = $20 - A, how many bytes to add to get to next line
      LD ($D33C),A   ;modify the code
      LD A,B         ;restore
      SUB $06
      NEG            ;A = $6 - A
      LD ($D303), A  ;modify the code: how many bytes to skip in rightmost visible block
      LD B,A         ;save
      LD ($D27C),A   ;modify the code: how many attribs to draw in leftmost visible block
      SUB $20
      NEG            ;A = $20 - A
      LD ($D27E),A   ;modify the code:
      LD A,B         ;restore

$D4AC SUB 6          
      NEG            ;A = 6 - A, how many bytes of rightmost block to draw
      ADD A,A        ;*2
      LD C,A
      LD B,0         ;into BC
;modify proc which draws leftmost block: change JP destinations so only part of leftmost block is drawn
      LD HL,$D256    ;jump base
      ADD HL,BC      ;add offset
      LD ($D254),HL  ;modify JP command destination
      LD HL,$D268
      ADD HL,BC
      LD ($D266),HL  ;modify JP command destination
      LD HL,$D299
      ADD HL,BC
      LD ($D297),HL  ;modify JP command destination
      LD HL,$D2AB
      ADD HL,BC
      LD ($D2A9),HL  ;modify JP command destination
      LD HL,$D2D6
      ADD HL,BC
      LD ($D2D4),HL  ;modify JP command destination
      LD HL,$D2E8
      ADD HL,BC
      LD ($D2E6),HL  ;modify JP command destination

$D4DE LD A,C
      SUB $0C
      NEG            ;A = $0C - A
      LD C,A         ;BC contains how many bytes in rightmost block to draw
;modify proc which draws rightmost block: change JP destinations so only part of rightmost block is drawn
      LD HL,$D312    ;jump base
      ADD HL,BC      ;add offset
      LD ($D310),HL  ;modify JP command destination
      LD HL,$D328
      ADD HL,BC
      LD ($D326),HL  ;modify JP command destination
      LD HL,$D35C
      ADD HL,BC
      LD ($D35A),HL  ;modify JP command destination
      LD HL,$D372
      ADD HL,BC
      LD ($D370),HL  ;modify JP command destination
      LD HL,$D3A0
      ADD HL,BC
      LD ($D39E),HL  ;modify JP command destination
      LD HL,$D3B6
      ADD HL,BC
      LD ($D3B4),HL  ;modify JP command destination


;part 1: draw upper, partially visible row of level blocks

;calculate how many of slices are visible based on ($C4EB),($C4ED)
;and patch the code of block-drawing procedures
;upper blocks are unusual: they don't have 1 or 2 low slices visible
;so this math is a little bit confusing: upper slice is actually slice 2 or 3
$D50E LD A,($C4ED)   ;how many line-pairs to draw in second horizontal slice
      XOR 4          ;flip upper bit
      LD B,A         ;into B
      LD A,($C4EB)   ;how many line-pairs to draw in upper horizontal slice of normal blocks
      SUB $04
      NEG            ;A=4-A, which makes a number of line-pairs in third slice
      ADD A,B        ;A - number of line-pairs in slices 2 and 3
      LD B,A         ;into B

      LD HL,$E9FD    ;opcode of "JP (IY)"
      AND $0C        ;keep bits 2 and 3
      JR Z,$D549     ;if they are 0, then B < 4, need to draw only one slice, jump

; jump here if upper slice has all lines
$D524 LD A,$04       ;draw all lines in upper slice
      LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
      LD A,B         ;restore
      SUB 4          ;subtract 4, so A contains how many line-pairs to draw in second horizontal slice (not more than 4)
      JR Z,$D555     ;jump out if 0
      LD ($D292),A   ;modify the code of proc $D243: how many line-pairs to draw in second slice
      LD ($D350),A   ;modify the code of proc $D302: how many line-pairs to draw in second slice
      LD ($D1CC),A   ;modify the code of proc $D183: how many line-pairs to draw in second slice
      LD ($D2C5),HL  ;modify the code of proc $D243: put "JP (IY)" after drawing second slice
      LD ($D38A),HL  ;modify the code of proc $D302: put "JP (IY)" after drawing second slice
      LD ($D201),HL  ;modify the code of proc $D183: put "JP (IY)" after drawing second slice
$D546 JP $D55E       ;so, second slice is a last one, jump out to draw
;jump here if upper slice has not all lines
$D549 LD A,B         ;restore value
      AND $03        ;keep bits 0 and 1 - number of lines to draw in upper slice
      LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
$D555 LD ($D288),HL  ;modify the code of proc, jump out after first slice
      LD ($D346),HL  ;modify the code of proc, jump out after first slice
      LD ($D1С0),HL  ;modify the code of proc, jump out after first slice


$D55E LD A,B         ;restore
      SUB 8
      NEG            ;A3=(8-B) how many line-pairs to skip in sprite
      ADD A,A
      ADD A,A        ;*4
      LD B,A
      ADD A,A
      ADD A,B        ;A4=A3*12 - offset from start of sprite (6 bytes in each line, 2 line pairs)
      LD E,A
      LD D,0         ;into DE
      LD ($C4DC),DE  ;store

      EXX
      LD HL,$5843    ;attrib adddr (arg for $D3CE)
      EXX
      LD IY,$D57E    ;return addr
      LD HL,$405B    ;video mem addr
$D57B JP $D3CE       ;clear video mem

;now draw the blocks

$D57E LD A,(IX)      ;get code of block
      INC IX         ;to next block
      AND $0F        ;mask, keep 4 low bits
      JR Z,$D5B1     ;skip drawing, if 0

;part 1.1: draw leftmost, partially visible block
$D585 ADD A,A
      ADD A,A        ;A = A*4
      LD L,A
      LD H,0         ;HL=(IX)*4
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC
      LD SP,HL       ;SP points to info of current block
      POP BC         ;BC contains sprite offset
      LD HL,($DB8E)  ;base address of shifted sprite set
      ADD HL,BC      ;HL contains start of shifted sprite of current block
      LD BC,($C4DC)  ;offset from the beginning of a sprite
      ADD HL,BC      ;arg for $D243 - start of sprite
      EXX
      LD L,A         ;
      POP DE         ;attribs
      LD A,($C4ED)   ;how many line-pairs to draw in second slice
      CP 4
      JP NZ,$D5FF    ;?
      LD D,E         
      EXX
      LD IY,$D5B1    ;return addr
      LD DE,$4043    ;video mem addr
$D5AE JP $D243       ;draw leftmost block
;end of part 1.1

;part 1.2: draw full-width blocks
$D5B1 LD A,($D24B)   ;invisible part of leftmost block, in 8-pixel bytes
      SUB $06
      NEG            ;A = 6-A, so it is a shift to the right for the beginning of a current block
      ADD A,$42      ;$42 - offset for a dynamic game screen start (2-nd row, 3-rd column)
      LD E,A         ;calc video addr E=$42+(6-($D24B))
$D5BB LD D,40        ;DE=video addr
      LD IY,$D603    ;return addr
      EXX
      LD L,A
      LD H,$58       ;HL is attribute area addr
      LD BC,$0020    ;offset to get to the next attrib line
      EXX
$D5C9 LD A,$04       ;init loop counter: how many blocks to draw
      LD ($C4DA),A   ;save here
;loop
$D5CE LD ($D604),DE  ;save DE (modify the code below)
$D5D2 LD A,(IX)      ;get next block's code
      INC IX         ;to next block
      AND $0F        ;mask
      JP Z,$D603     ;if 0, don't draw
$D5DC ADD A,A
      ADD A,A        ;*4
      LD L,E
      LD H,0         ;to HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to info for specific block
      POP BC         ;read sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      LD BC,($C4DC)  ;offset from the beginning of a sprite (since upper part is not visible)
      ADD HL,BC      ;HL points to the part of a sprite to be drawn
      EXX
      LD A,L
      ADD A,$06      
      LD L,A         ;since attribs are drawn backwards, add block's with 6
      POP DE         ;read block's colour attribs
      LD A,($C4ED)   ;if only one slice
      CP 4
      JP NZ,$D5FF
      LD D,E         ;then D contains attrib of second slice
$D5FF EXX
$D600 JP $D183       ;draw a block
$D603 LD DE,???      ;restore video-mem address (this place in code is modified above at $D604)
      LD A,E
      ADD A,5
      LD E,A         ;move to 5 bytes to the right
      EXX
      LD L,A         ;attribs too
      EXX
$D60D LD HL,$C4DA
      DEC (HL)       ;decrement block counter
      JP NZ,$D5CE    ;loop
;end of part 1.2

;part 1.3: draw rightmost, partially visible block
$D614 LD A,(IX)      ;get code of current block
      LD BC,$19      ;
      ADD IX,BC      ;jump to the leftmost block of next row
      AND $0F        ;mask
      JR Z,$D647     ;if 0 then don't draw
      ADD A,A        
      ADD A,A        ;*4
      LD L,A
      LD H,$00
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC
      LD SP,HL       ;SP points to info for current block
      POP BC         ;read block's sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      LD BC,($C4DC)  ;how many bytes to skip from the sprite
      ADD HL,BC
      EXX
      POP DE         ;read color attribs for current block from info
      LD A,($C4ED)
      CP $04
      JP NZ,$D63F
      LD D,E
      EXX
      LD IY,$D647    ;return addr
$D644 JP $D302       ;call: draw a rightmost, not fully visible block
;end of part 1.3

;calculate video-mem address for next block to draw
$D647 LD DE,$????    ;restore video-mem address (stored here from code above)
$D64A LD A,($C4ED)   ;how many line-pairs in upper slice
      XOR 4
      LD B,A
      LD A, ($C4EB)  ;how many line-pairs in second slice
      SUB $04
      NEG
      ADD A,B
      LD B,A         ;B contains number of line-pairs in drawn slices
      AND $0C        ;mask
      JR Z,$D668
      LD C,$40
      CP $08
      JR Z, $D665
      LD C,$20
D665: LD A,E
      ADD A,C
      LD E,A
D668: LD A, B
      AND $03
      ADD A,A
      ADD A,D
      LD D,A         ;video-mem address for next block calculated
      EX AF,AF'
      LD A,E
      EXX
      LD L, A
      EX AF, AF'
      RRCA
      RRCA
      RRCA
      AND $03
      OR $58
      LD H, A        ;attrib-address for next block calculated
      EXX
;end of part 1

;part 2: draw middle, fully visible rows of level blocks

$D67C LD HL,$20C6    ;machine code for command "ADD A,$20"
      LD ($D288),HL  ;modify the code of proc $D243, it should draw 3 slices
      LD ($D2C5),HL
      LD ($D346),HL  ;modify the code of proc $D302: it should draw 3 slices
      LD ($D38A),HL
      LD HL,$C67D    ;opcodes of "LD A,L; ADD A,..."
      LD ($D1C0),HL  ;modify the code of proc $D183: it should draw 3 slices
      LD ($D201),HL
      LD A,$04       ;how many line-pairs draw in second slice
      LD ($D292),A   ;modify the code of proc $D243: how many line-pairs to draw in second slice
      LD ($D350),A   ;modify the code of proc $D302: how many line-pairs to draw in second slice
      LD ($D1CC),A   ;modify the code of proc $D183: how many line-pairs to draw in second slice
      LD A,($C4EB)   ;on how many line-pairs block rizes above row ?
      LD HL,$E9FD    ;opcode of "JP (IY)"
      AND A
$D6A6 JR NZ,$D6BF    ;if block rizes above row, jump
      LD A,$04       ;otherwise, it has 4 line-pairs in upper slice
      LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
      LD ($D2C5),HL  ;modify the code of proc $D243: put "JP (IY)" after drawing second slice
      LD ($D38A),HL  ;modify the code of proc $D302: put "JP (IY)" after drawing second slice
      LD ($D201),HL  ;modify the code of proc $D183: put "JP (IY)" after drawing second slice
$D6BC JP $D6D5       ;and skip part below
;block will have 3 slices, number of line-pairs in upper slice is in reg A
$D6BF LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
      SUB $04
      NEG            ;A = 4 - A, it will be number of line-pairs in third slice
      LD ($D2CF),A   ;modify the code of proc $D243: how many line-pairs to draw in third slice
      LD ($D394),A   ;modify the code of proc $D302: how many line-pairs to draw in third slice
      LD ($D20D),A   ;modify the code of proc $D183: how many line-pairs to draw in third slice

$D6D5 LD A,$07
      LD ($C4DB),A   ;there will be 7 rows of blocks

$D6DA EXX            ;now for attribute addresses
      LD ($D714),HL  ;store, modify code below
      EXX            ;back to pixel-area addresses
$D6DF LD HL,??       ;restore, this code is modified
      LD ($D6EE),HL  ;store, modify code below
      LD ($D720),DE  ;store, modify code below

;big loop to draw all rows of blocks

$D6E9 LD IY,$D6F3    ;return addr
$D6ED LD HL,??       ;restore
$D6F0 JP $D3CE       ;call: clear video memory

;part 2.1: draw leftmost, partially visible block
$D6F3 LD ($D6EE),HL  ;store, modify code
      LD DE,($D720)  ;restore video-mem pixel area addr
      LD A,(IX)      ;get block code
      INC IX         ;move to next block
      AND $0F        ;mask
      JR Z,$D71F     ;don't draw if there are no low bits
      ADD A,A
      ADD A,A        ;*4
      LD L,A
      LD H,$00       ;into HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC
      LD SP,HL       ;SP points to specific block info
      POP BC         ;read sprite offset
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset
      EXX
$D713 LD HL,??       ;restore HL (attrib addr), this value in code is modified
      POP DE         ;read block's attrib values
      EXX
$D718 LD IY,$D71F    ;return addr
$D71C JP $D243       ;draw a leftmost, partly visible block
;end of part 2.1

;part 2.2: draw full-width blocks
$D71F LD DE,$48C3    ;restore DE (video mem addr), this value is modified above
$D722 LD A,($D24B)
      SUB $06
      NEG
      DEC A
      ADD A,E
      LD E, A
      LD IY,$D767    ;return addr for JP $D183 later
      EXX            ;will work with alt registers which control attribute drawing
      LD HL,($D714)  ;restore HL (attrib addr, saved inside code above)
      LD L,A
      LD ($D770),HL  ;save HL (modify the code below)
      LD C,$20
      EXX            ;back
$D73B LD A,$04       ;init loop counter: how many block to draw
      LD ($C4DA),A   ;save here
;loop
$D740 LD ($D768),DE  ;save DE (modify the code below)
      LD A,(IX+$00)  ;get block code
      INC IX         ;to next block
      AND $0F        ;mask
      JP Z,$D767     ;if has high part, don't draw
      ADD A,A
      ADD A,A        ;*4
      LD L,A
      LD H, 00       ;to HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to specific block info
      POP BC         ;read sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      EXX            ;now we will prepare params in alternative regs
      LD A,L
      ADD A,$06
      LD L,A         ;address in attrib mem area
      POP DE         ;read two attrib values
      EXX            ;prepared
$D764 JP $D183       ;call: draw a block
$D767 LD DE,$48D5    ;restore DE (video mem addr), this value is modified above
      LD A,E
      ADD A,$05      ;shift right by 5 bytes (width of block)
      LD E,A
      EXX
$D76F LD HL,??       ;restore HL (attrib addr), this value in code is modified
$D772 LD L,A         ;shift right by 5 bytes
      LD ($D770),HL  ;modify the code, save HL for next loop
      EXX
      LD HL,$C4DA
      DEC (HL)       ;decrement block counter
$D77B JP NZ, $D740   ;loop
;end of part 2.2

;part 2.3: draw rightmost, partially visible block
$D77E LD A,(IX+$00)  ;get code of current block
      LD ($D7A4),DE  ;save by writing directly in the code later
      AND $0F        ;mask block code bits
      JP Z,$D7A3     ;no lower bits - don't draw
      ADD A,A
      ADD A,A        ;*4
      LD L,A
      LD H,$00       ;into HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to info for current block
      POP BC         ;read block's sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      EXX            ;now we prepare params in alternative regs
      POP DE         ;read color attribs for current block from info
      EXX
      LD IY,$D7A3    ;return addr
$D7A0 JP $D302       ;call: draw a rightmost, not fully visible block
;end of part 2.3

$D7A3 LD DE,??       ;restore video-mem address
      LD A,E
      AND $E0
      ADD A,$43
      LD E,A
      SBC A,A
      AND $08
      ADD A,D
      LD D,A         ;calc next video-mem addr
      LD ($D720),DE  ;save this value into a code above
      LD BC,$0019    ;how much blocks should we skip
      ADD IX,BC      ;skip these blocks
      EX AF,AF'      ;save reg A
      LD A,E
      EXX            ;now will work with attribs
      LD L,A
      EX AF,AF'
      RRCA
      RRCA
      RRCA
      AND $03
      OR $58
      LD H,A         ;re-calc attrib address
      LD ($D714),HL  ;save into a code above
      EXX            ;finished with attributes
      LD HL,$CC7A    ;current "row" (consisting of 8 pixel lines), argument for JP $C9F6 below
      INC (HL)
      INC (HL)       ;increment by 2
      LD ($D7DD),IX  ;save pointer to current block in code below
$D7D4 LD IY,$D7DB    ;return address
$D7D8 JP $C9F6       ;draw dynamic objects
$D7DB LD IX,??       ;restore IX
$D7DF LD HL,$C4DB    ;number of remaining "rows" (of 8 pixel lines)
$D7E2 DEC (HL)       ;decrement it
$D7E3 JP NZ,$D6E9    ;if still something to draw, repeat the big loop
;end of part 2

;part 3: draw lowest, partially visible row of level blocks

;calculate how many of slices are visible based on ($C4EB),($C4ED)
;and patch the code of block-drawing procedures
$D7E6 LD DE,($D720)  ;restore DE
      LD HL,$20C6    ;opcode of "ADD A,$20"
      LD ($D2C5),HL  ;modify the code of proc $D243 so it draws 3 slices
      LD ($D38A),HL  ;modify the code of proc $D320 so it draws 3 slices
      LD HL,$C67D    ;opcodes of "LD A,L; ADD A,..."
      LD ($D201),HL  ;modify the code of proc $D183 so it draws 3 slices
      LD A,($C4EB)   ;on how many line-pairs block rises above the row
      LD HL,$E9FD    ;opcode of "JP (IY)"
      AND A
$D800 JP Z,$D828     ;jump if block doesn't rise above row
      LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
      LD A,($C4ED)   ;how many line-pairs to draw in second slice
      AND A
$D810 JP Z, $D838    ;jump if 0
      LD ($D292),A   ;modify the code of proc $D243: how many line-pairs to draw in second slice
      LD ($D350),A   ;modify the code of proc $D302: how many line-pairs to draw in second slice
      LD ($D1CC),A   ;modify the code of proc $D183: how many line-pairs to draw in second slice
      LD ($D2C5),HL  ;modify the code of proc $D243: put "JP (IY)" after drawing second slice
      LD ($D38A),HL  ;modify the code of proc $D302: put "JP (IY)" after drawing second slice
      LD ($D201),HL  ;modify the code of proc $D183: put "JP (IY)" after drawing second slice
$D825 JP $D841       ;jump
;this code is executed if second-slice is the upper slice
$D828 LD A, ($C4ED)  ;how many line-pairs to draw in second slice
      AND A
$D82C JP Z, $D8DA    ;if 0 then jump away
      LD ($D24F),A   ;modify the code of proc $D243: how many line-pairs to draw in upper slice
      LD ($D306),A   ;modify the code of proc $D302: how many line-pairs to draw in upper slice
      LD ($D186),A   ;modify the code of proc $D183: how many line-pairs to draw in upper slice
$D838 LD ($D288),HL  ;modify the code of proc $D243: put "JP (IY)" after drawing upper slice
      LD ($D346),HL  ;modify the code of proc $D302: put "JP (IY)" after drawing upper slice
      LD ($D1C0),HL  ;modify the code of proc $D183: put "JP (IY)" after drawing upper slice

;part 3.1: draw leftmost, partly visible block
$D841 LD A,(IX+$00)  ;get block code
      LD ($D868),DE  ;save DE (video mem pixel area addr) into code below
      INC IX         ;to next block
      AND $0F        ;mask
$D84C JR Z,$D867     ;no low bits - nothing to draw
      ADD A,A
      ADD A,A        ;*4
      LD L,A
      LD H,$00       ;into HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to specific block info
      POP BC         ;read sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      EXX            ;will work with alt registers which control attribute drawing
      POP DE         ;read attribute values for block
      EXX            ;back to pixel-area addresses
      LD IY,$D867    ;return addr
$D864 JP $D243       ;call: draw a block
;end of part 3.1

;part 3.2: draw full-width blocks
$D867 LD DE,??       ;restore DE (video mem addr)
      LD A,($D24B)
      SUB $06
      NEG
      DEC A
      ADD A,E
      LD E,A         ;recalc video-mem addr
      LD IY,$D8A9    ;return addr
      EXX            ;will work with attrib addresses
      LD L,A         ;
      LD C,$20       ;recalc them
      EXX            ;back to pixel addresses
      LD A,$04       ;init loop counter how many full-width blocks in row
      LD ($C4DA),A   ;save
$D882 LD ($D8AA),DE  ;save video mem pixel area, modify code below
      LD A,(IX)      ;code of current block
      INC IX         ;move to next block
      AND $0F        ;mask
      JP Z,$D8A9     ;if no low bits, then don't draw
      ADD A,A
      ADD A,A        ;*4
      LD L, A
      LD H, $00      ;into HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to specific block info
      POP BC         ;read sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      EXX            ;now we will prepare params in alternative regs
      LD A, L
      ADD A, $06
      LD L, A
      POP DE         ;read two attrib values
      EXX            ;back to pixel-area addresses
$D8A6 JP $D183       ;draw full-width block
$D8A9 LD DE,??       ;restore video-mem address, this code is modified
      LD A,E
      ADD A,$05
      LD E,A         ;to next block (to the right)
      EXX            ;to attributes
      LD L, A        ;update address
      EXX            ;back to pixels
      LD HL,$C4DA    ;how many blocks are left to draw
      DEC (HL)       ;decrement block counter
$D8B7 JP NZ,$D882    ;loop if there are still blocks to draw
;end of part 3.2

;part 3.3: draw rightmost, partly visible block
$D8BA LD A,(IX)      ;get next code of current block
      AND $0F        ;mask
      JR Z,$D8DA     ;no low bits - don't draw
      ADD A,A
      ADD A,A        ;*4
      LD L,A
      LD H,$00       ;into HL
      LD BC,$DB5A    ;base addr for table of block infos
      ADD HL,BC      ;add offset
      LD SP,HL       ;SP points to info for current block
      POP BC         ;read sprite offset into BC
      LD HL,($DB8E)  ;base address of shifted sprite-set
      ADD HL,BC      ;add block's sprite offset. HL points to shifted sprite
      EXX            ;now we prepare params in alternative regs
      POP DE         ;read color attribs for current block from info
      EXX
      LD IY,$D8DA    ;return addr
$D8D7 JP $D302       ;call: draw block
;end of part 3.3

;patch-back drawing procedures so they draw 3 slices
$D8DA LD HL,$20C6    ;opcode of "ADD A,$20"
      LD ($D288),HL  ;modify the code of proc $D243: put "ADD A,$20" after drawing second slice
      LD ($D2C5),HL  ;modify the code of proc $D243: put "ADD A,$20" after drawing first slice
      LD ($D346),HL  ;modify the code of proc $D302: put "ADD A,$20" after drawing second slice
      LD ($D38A),HL  ;modify the code of proc $D302: put "ADD A,$20" after drawing first slice
      LD HL,$C67D    ;opcodes of "LD A,L; ADD A,..."
      LD ($D1C0), HL ;modify the code of proc $D183
      LD ($D201), HL ;modify the code of proc $D183
      LD IY,$D8FE    ;return addr
      LD A,$FF
      LD ($CC7A),A   ;argument for JP $C9F6 below
$D8FB JP $C9F6       ;draw dynamic objects
;end of part 3

$D8FE LD SP,($DB90)  ;restore stack pointer
$D902 RET            ;return

--------------------
$D903: Find sprite descriptors for level - $D91F

Param: ($C398) - level number
Result: IX - list of level block sprite numbers used in level
        IY - color attribs for sprites (2 bytes, one for top, one for bottom)

$D903 LD A,($C398)   ; get level
      LD L,A
      LD H,$00       ;into HL
      ADD HL,HL
      ADD HL,HL      ;*4
      LD B,H
      LD C,L         ;save
      ADD HL,HL
      ADD HL,HL
      ADD HL,HL      ;*32
      ADD HL,BC      ;finally, HL = A*36
      LD BC,$DA16    ;table base
      ADD HL,BC      ;add offset
      PUSH HL
      POP IX         ;into IX
      LD BC,$000C
      ADD HL,BC      ;add $0C
      PUSH HL
      POP IY         ;into IY
$D91F RET

--------------------

$D920: Prepare sprite set for level's blocks with horizontally shifted versions - $D9C4

;unpack sprites into temp area
$D920 LD DE,$5D00    ;base address of all packed sprites
      LD HL,$EBFD    ;temp area where all sprites will be unpacked
      CALL $D9E5     ;unpack sprites into temp area

$D929 CALL $D903     ;get sprite numbers into IX, sprite colors into IY

;IX points to list of level's sprites
;create level's sprite set from this list at temp area starting at address $9D72
$D92C LD DE,$9D72    ;address for level's sprite set
$D92F LD B,$0C       ;how many sprites in sprite set
;loop
$D931 PUSH BC        ;save
      LD A,(IX)      ;number of sprite
      DEC A          ;dec
      LD L,A
      LD H,$00       ;into HL
      ADD HL,HL
      ADD HL,HL
      ADD HL,HL
      ADD HL,HL      ;*16
      LD B,H
      LD C,L         ;save
      ADD HL,HL
      ADD HL,HL      ;*64
      ADD HL,BC      ;finally HL = ((IX) - 1)*80
      INC IX
      LD BC,$EBFD    ;unpacked sprites base
      ADD HL,BC      ;HL points to sprite
      LD BC,$0050    ;80 bytes = width(5)*height(2*8)
      LDIR           ;move
      POP BC         ;restore
      DJNZ $D931

;copy level's sprite-set to temp area, expanding width from 5 to 6 bytes
$D950 LD HL,$9D72    ;sprite-set for current level
      LD DE,$EBFD    ;unpacked sprites base
      LD A,$C0       ;sprite-set height
$D958 EX AF,AF'
      LD BC,$0005    ;sprite width - 5 bytes
      LDIR           ;copy
      XOR A
      LD (DE),A      ;and put 6th byte with value 0
      INC DE
      EX AF,AF'
      DEC A
      JR NZ,$D958    ;loop

;make several horizonally-shifted copies of sprite-set
;each subsequent copy is shifted 2 pixels to the right relative to previous copy
;so there is an unshifted original and 3 copies
;sprite width is 6 bytes
$D965 LD HL,$EBFD    ;sprite-set start
      LD DE,$F07D    ;right after it's end
      LD BC,$0480    ;size
      LDIR           ;copy
      CALL $D9C5     ;shift to the right at new location
      LD HL,$F07D
      LD DE,$F4FD
      LD BC,$0480
      LDIR           ;copy shifted
      CALL $D9C5     ;shift at new location
      LD HL,$F4FD
      LD DE,$F97D
      LD BC,$0480
      LDIR           ;copy shifted again
      CALL $D9C5     ;shift at new location

;copy colour info into area starting at $DB60
$D98F LD HL,$DB60    ;attrib area start
      LD B,$0C
$D994 LD E,(IY+$00)  ;block's top color attrib
      LD D,(IY+$01)  ;block's bottom color attrib
      INC IY
      INC IY
      LD (HL),E
      INC HL
      LD (HL),D      ;copy to HL
      INC HL
      INC HL
      INC HL         ;skip two bytes
      DJNZ $D994

$D9A6 LD HL,$EBFD
      LD ($DB8E),HL  ;save shifted sprites base addr here

      LD HL,$FE00
      LD DE,$FE01
      LD BC,$0100
      LD (HL),$FD
      LDIR           ;fill area from $FE00 with $FD (interrupts?)
      LD A,$C3
      LD ($FDFD),A   ;JP command code
      LD HL,$A223    ;addr for interrupt handler
      LD ($FDFE),HL
$D9C4 RET            

--------------------
$D9C5: Shift memory area of 6 byte-strings to the right by 1 bit - $D9E4

Param: HL - address in memory
shifts (6 bytes string)*($0C*$10 times)

$D9C5 PUSH HL        ;save addr
      AND A
      LD E,$0C       ;how many sprites in sprite-set
$D9C9 LD D,$10       ;how many 6-byte lines in sprite

;shifts a string of 6 bytes in memory to the right
;low bit of each byte goes to high bit of next byte
$D9CB LD C,$02       ;how many times to shift
$D9CD PUSH HL        ;save addr
      LD B,$06       ;6 bytes to rotate
      RR (HL)        ;rotate byte to the right
      INC HL         ;to next byte
      DJNZ $D9D0     ;inner loop
      POP HL         ;restore addr
      DEC C          ;decrement outer loop counter
$D9D7 JR NZ,$D9CD    ;outer loop, shift again all those bytes

$D9D9 LD BC,$0006    ;to next 
      ADD HL,BC
      DEC D          ;decrement big counter
      JR NZ,$D9CB    ;loop
      DEC E          ;decrement mega-big counter
      JR NZ,$D9C9    ;loop
      POP HL         ;restore addr
$D9E4 RET


--------------------
$D9E5: Unpack sprites into temp area - $DA14 (+1)

Params: HL - temp area
        DE - sprite source area

$D9E5 LD BC,$FEBD    ;end of sprites temp area
      LD ($A79C),BC  ;modify the code of compare procedure
      XOR A
      LD ($C4C8),A   ;init shift accumulator with 0
$D9F0 LD C,$08
      CALL $A76C     ;unpack 8 bits into A
      LD (HL),A      ;put result
      INC HL
$D9F7 LD B,A         ;remember value
      LD C,$08
      CALL $A76C     ;unpack 8 bits into A
      LD (HL),A      ;put result
      INC HL
      CALL $A799     ;compare HL with $FEBD
      RET NC         ;exit if reached
      CP B           ;compare with prev value
$DA04 JR NZ,$D9F7    ;if they are different, just keep copying

;if two subsequent values are the same, then unpack 4 bits as counter and copy this value
$DA06 LD C,$04
      CALL $A76C     ;unpack 4 bits into A - it is a counter
$DA0B DEC A          ;decrement counter
      AND $0F
      JR Z,$D9F0     ;if counter is 0, then return to main loop
      LD C,A
      LD (HL),B      ;put value into memory
      INC HL         ;to next addr
      LD A,C
$DA14 JR $DA0B       ;keep writing the same value into memory


--------------------
$DA16: Sprite-set info for blocks of levels.
       36 bytes for each level describe 12 blocks: 12 bytes are sprite numbers, 
       and then 24 bytes are color-pairs for sprites (top color, bottom color)

$DB5A: Level blocks info table
       4 bytes for each block:
             2 bytes are sprite offset from base of current level's sprite set
             2 bytes are color attribs: one for top slice of block, another for bottom
       Looks like the first block is pre-defined (empty ?)

$DB8E (2) : base address for sprite-set of level blocks for current horizontal shift
$DB90 (2) : Temp storage for SP

$DB92: Addresses of handlers for monster/missile collision detection: $B8BC, $B8BF, $B8EA

$DBCC: Message table. 2 bytes for each message pointer

DDB1 ?

<======================================>
$E576:  Набор процедур и данных для меню, демо, таблицы очков - $????<


$E576: Loop for menu,demo and high score table - $E5B3 (+2 bytes)
==============================

$E576 CALL $EAEC   ;clear screen
$E579 LD HL,$E960  ;"Graphical script" for main menu
$E57C LD BC,01  
$E57F CALL $E5C4    ;execute script for main menu
....                
$E58B CALL $E5EB    ;play music until key will be pressed (ZF=0) or music will end (ZF=1)
$E58E JR Z,$E5A0    ;if music ended without any keys pressed, jump to "demo"
$E590 LD A,B
$E591 AND A
$E592 RET Z         ;if "fire" button was pressed (B=0), then return to main loop (which will start the game) 

;begin of loop without music
$E593 CALL $E87C    ; change control joystick and print it
$E596 CALL $E5D3    ; just read the keyboard without music 
$E599 JR Z,$E5A0    ; if no keys were pressed, then jump to "demo"
$E59B LD A,B
$E59C AND A
$E59D RET Z         ;if "fire" button was pressed (B=0), then return to main loop (which will start the game) 
$E59E JR $E593      ;otherwise loop again

$E5A0 CALL $E8AB    ;Show "demo". Returns when demo ends (ZF=1) or keypress (ZF=0)
$E5A3 JR NZ $E576   ;If key was pressed, jump to the main menu

$E5A5 LD HL,$E9DF   ;"graphical script" for game authors
$E5A8 CALL $E5B5    ;show script, return by timeout (ZF=1) or keypress (ZF=0)
$E5AB JR NZ $E576   ;if key was pressed, jump to the main menu

$E5A5 LD HL,$EA4F   ;"graphical script" for high score table
$E5B0 CALL $E5B5    ;show script
$E5B3 JR $E576      ;in any case, keypress or timeout, jump to main menu

-----------------------------------------

$E5B5: Draw a screen basen on "graphical script" and await cycle with keyboard scan - $E5EA

Entry point $E5B5 - with clearing of the screen
Entry point $E5С4 - without clearing of the screen
Params: HL - address of a "graphical script"

$E5B5 EXX           ;save registers
$E5B6 CALL $EAEC    ;clear the screen
$E5B9 EXX           ;restore registers
$E5BA LD A,(HL)     ;load attribute value
$E5BB INC HL
$E5BC EXX           ;save all regs except A
$E5BD CALL $EAFA    ;fill color attributes with value of A
$E5C0 EXX           ;restore all regs
$E5C1 LD BC,$0180   ;time delay value

;second entry point
$E5C4 LD ($E93E),BC ;time delay
$E5C8 LD A,(HL)     ;get message color
$E5C9 INC HL        
$E5CA LD ($C32F),A  ;set message color as current
$E5CD CALL $C1FC    ;print messages
$E5D0 CALL $C23A    ;draw attributes

; now there is a cycle of keyboard reads and delays. Exits if any key is pressed or time is out
; value of loop counter is in ($E93E)
$E5D3 CALL $A241    ; keyboard scan
$E5D6 RET NZ        ; return if key was pressed
$E5D7 LD A,01
$E5D9 LD BC,$0A60   ; A,B,C contain time delay value
$E5DC CALL $A4E1    ; wait for specified delay
$E5DF LD HL,($E93E) ; counter of inactivity cycles
      DEC HL        ; decrement it
      LD ($E93E),HL ; and store
      LD A,H
      OR L
      JR NZ $E5D3   ; repeat cycle while inactivity counter is not 0
$E5EA RET           ; otherwise, exit


-----------------------------------------

$E5EB: Главный цикл музыки (с данными и переменными) - $E7D2


$E5EB LD HL,$E795   ;установить глобальный указатель на начало
$E5EE LD ($E741),HL ;сохранить глобальный указатель
$E5F1 LD A,(HL)     ;получаем номер сэмпла в регистр A
$E5F2 CP $FF        ;проверяем маркер конца
$E5F4 RET Z         ;если конец - выходим из цикла
$E5F5 - ...
;получаем адрес HL = $E775+(A*2) - адрес записи в указательной таблице сэмплов.
... - $E5FC
$E5FD - ...
;получаем в HL адрес из указательной таблицы на данные сэмпла
... - $E600
;;;$E601 - $E6B9 (+2) - внутренний цикл главного меню, 
$E601 LD ($E743),HL ;cохранение локального указателя на текущую амплитуду внутри текущего сэмпла. каждый цикл увеличивается на 1
$E604 CALL $A241    ;опрос клавиатуры
$E607 RET NZ        ;возврат, если нажимали клавишу
$E608 - ...
;опрос порта 1FFE или 0FFE (в зависимости от $C4B2)
;если не в нуле один из младших 5 битов, то возврат
... - $E61A
$E61B LD HL,($E743) ;восстановление указателя амплитуды 
$E61E LD A,(HL)     ;получаем значение амплитуды ($16 - меню, $FF - конец семпла)
$E61F - ...
;в зависимости от значения, переход на $E643, $E632, $E6D5, $E63A
... - $E642

$E643 ???
$E6B9 JP E601       ;повтор цикла

;;;;;;;;; вызывается из внутреннего цикла
$E6BC - $E6D4 ????

;сюда переход, если "нота" $FF
$E6D5 LD HL,($E741) ; восстановить глобальный указатель
$E6D8 INC HL        ; увеличить указатель
$E6D9 JP $E5EE      ; повторить цикл

--------------------------------
$E6DC: Play specified sound

$E6DC LD BC,$0010
$E6DF LD HL,$0100
$E6E2 LD DE,$00A
;then fall to generic play proc

--------------------------------

;;;;;;;
;E6E5 - $E73F - процедура вывода амплитуды на динамик

Params: DE
        HL

Переменные данного куска:
$E741 (2) - указатель на номер текущего сэмпла
$E743 (2) - указатель на текущую амплитуду для текущего сэмпла
$E775 - $E794 - указательная таблица на информацию о сэмплах (номер сэмпла от 00 до 0F)
$E795 - $E7D2 - последовательность сэмплов для музыки из меню.
Сэмплы начинаются по адресам:
$E7D3, $E7DD, $E7E6, $E7EF, $E7F9, $E803, $E80C, $E82A, $E834, $E83D, $E847, $E850, $E85A, $E863, $E86D, $E876 - $E87B


-----------------------------------------
$E87C: Смена и печать текущего джойстика - $E8AA

$E87C LD A,($C4B2)  ;получаем индекс текущего джойстика
$E87F INC A         ;меняем на следующий
$E880 AND $03       ;отрезаем переполнение (после 3-его будет нулевой)
$E882 LD ($C4B2),A  ;сохраняем
$E885 - $E88E ;умножаем индекс на 8 (по 8 букв на джойстик) и прибавляем к $E940 (Начало названий джойстиков)
;получаем в HL указатель на название джойстика
$E88F LD DE,$E9B1   ;В DE - адрес шаблона для печати названия текущего джойстика
$E892 LD C,8        ;длина названия джойстика - 8 букв
$E894 LDIR          ;Копируем название текущего джойстика в шаблон
$E896 LD A,$A0      ;
$E898 LD ($E93E),A  ; сброс счетчика для процедуры времени до начала демо
$E89B XOR A         ;
$E89C LD ($C32F),A  ; ????
$E89F LD HL,$E9AF   ;название текущего джойстика
$E8A2 CALL $C1FC    ;печатаем на экран
$E8A5 CALL $A241    ;опрос клавиатуры
$E8A8 JR NZ,$E8A5   ;в цикле
$E8AA RET           ;выход

-----------------------------------------
$E8AB: "Demo" - $E93D

$E8AB XOR A         ;A=0
$E8AC LD ($C3A7),A  ;?? lives
$E8AF LD ($C4B1),A  ;??
$E8B2 INC A         ;A=1
$E8B3 LD ($C4DA),A  ;set flag to skip "get ready" delay
$E8B6 CALL $A47B    ;draw game screen static decorations
$E8B9 LD A,($C4C7)  ;level to show in demo
$E8BC LD ($C398),A  ;store
$E8BF XOR 04        ;invert 3-d bit (demo uses levels 0 and 4)
$E8C1 LD ($C4C7),A  ;store for next demo
$E8C4 CALL $A58D    ;init grahics for level
$E8C7 CALL $C4EE    ;???? clear some memory
$E8CA CALL $C50C    ;Init coordinates and shifts in 0
      LD HL,0
      LD ($C4E8),HL ;current coordinates (in blocks)
      XOR A
      LD ($C3A9),A
      LD A,$46
      LD ($C32F),A  ;attribute
$E8DC CALL $D431    ;draw game screen
      LD A,02
$E8E1 CALL $A4E1    ;pause

;loop
$E8E4 CALL $A241    ;keyboard query
$E8E7 JR NZ $E935   ;if key was pressed, then exit
$E8E9 LD A,$FE
$E8EB LD I,A        ;reg I points to interrupt table for IM2
$E8ED EI            ;enable interrupts
$E8EE HALT          ;wait for interrupt
$E8EF LD D,01
$E8F1 LD BC,0360    ;D,B,C contain pause value
$E8F4 CALL $A4E2    ;do the pause
$E8F7 CALL $C819    ;calculate full coords in pixels
$E8FA CALL $D431    ;draw game screen
      LD A,($C4C7)  ;current level number
      AND A         ;check if 0
      JR Z,$E90A
      LD A,$0C      ;if not 0, then current message is $0C ("GraftGold")
      CALL $C1AD    ;draw the message
$E908 JR $E90F      ;continue
$E90A LD A,$0D      ;if 0, then current message is $0D ("Soldier of fortune")
$E90C CALL $C1AD    ;draw the message
$E90F CALL $BAB2    ;colliding dynamic objects list maintenance
      CALL $BED1    ;update coordinates of dynamic objects
      CALL $BD7F    ;????
      CALL $CEDC    ;????
      CALL $A1FC    ;проверка паузы?
$E91E CALL $C1B5    ;печать текущего сообщения
      CALL $C9CF    ;сдвиг экрана вниз
      CALL $C9CF    ;ещё раз
      CALL $C924    ;сдвиг экрана вправо
      CALL $C924    ;ещё раз
$E92D JR NZ,$E8E4   ;переход на следующий цикл "демо", если не достигли правого края
;конец цикла "демо"

.....
$E934 XOR A         ;устанавливаем флаг нуля для вызывавшей процедуры (флаг, что клавиши не нажимались)
$E935 PUSH AF       ;сохраняем регистры
$E936 CALL $A887    ;???
$E939 CALL $E8A5    ;вызываем опрос клавиатуры в цикле
$E93C POP AF        ;восстанавливаем регистры
$E93D RET           ;возврат из "демо"


-----------------------------------------
Переменные:

$E93E - how many time cycles till the end of current script
$E940 - 4*8 букв, названия джойстиков (4 джойстика по 8 букв)
$E960 - "graphical script" for main menu
$E9AF - шаблон для печати текущего джойстика. Сначала 2 координаты, а с $E9B1 - 8 букв для названия.
$E9DF - "graphical script" for game authors



-----------------------------------------
$EAEC: Clear screen - $EB06 
$EAEC: First entry point. Clears screen and sets all attributes to value $47
$EAEE: Second entry point. Clears screen (sets screen memory values to 0) and sets all attributes to value provided by reg A
$EAFA: Third entry point. Sets all attributes to value provided by reg A 


-----------------------------------------

$EBFD - Temp area. Used for:
                      * to draw game window border decorations
                      * to unpack sprites
                      * to store horizonally-shifted versions of level sprite-set (blocks, moon,...)
                                              since each block has width 5, for shifted versions use width 6

<======================================>

До этого места, похоже, мешанина данных

$FDFD - обработчик прерываний IM2. Единственная команда: JP $A223

$FE00 - $FF00 - Таблица прерываний.
Заполнена значениями $FD, так что обработчик прерываний - $FDFD



